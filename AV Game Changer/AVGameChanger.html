<!DOCTYPE html><html lang="en">
<!--
SPECS TO CHECK EACH TIME:
‚úÖ Floor plan must be draggable when image is loaded
‚úÖ Clicking floor plan background deselects everything and exits the routing routine
‚úÖ TV assignment counts on channel cards should be WHITE text
‚úÖ Highlight/glow around TVs when selected should be prominent.
‚úÖ Remove TV count blob from channel cards - too distracting
‚úÖ Right-justify category tags (SPORTS/NEWS) so they don't interfere with channel ID
‚úÖ Channel numbers same size as station ID - users go by numbers a lot
‚úÖ Floor plan buttons (Load Plan, Invert, Size, Reset TVs) nested under Admin menu
‚úÖ Debug mode shows IP addresses on TV icons (can expand container if needed)
‚úÖ Autosave app state every 5 mins, save to internal memnory, app should load with previous state.
‚úÖ app should load as a PWA (ok to simulate for now, no address bar, bookmarks, etc
‚úÖ Optimize fort full screen on a 10.9 inch apple ipad, no scroll bars. Does not need to be mobile responsive, I have a scaled down smart phone version.
‚úÖ AI helps must load the full app and not truncate sections, everything must work, No "Will work in final version", everything should always work.
‚úÖ These specs as comments at top for reference
-->
    <head><meta http-equiv="Content-Security-Policy" content="default-src 'self' 'unsafe-inline' 'unsafe-eval' data: blob: https://cdnjs.cloudflare.com https://cdn.jsdelivr.net https://code.jquery.com https://unpkg.com https://d3js.org https://threejs.org https://cdn.plot.ly https://stackpath.bootstrapcdn.com https://maps.googleapis.com https://cdn.tailwindcss.com https://ajax.googleapis.com https://kit.fontawesome.com https://cdn.datatables.net https://maxcdn.bootstrapcdn.com https://code.highcharts.com https://tako-static-assets-production.s3.amazonaws.com https://www.youtube.com https://fonts.googleapis.com https://fonts.gstatic.com https://pfst.cf2.poecdn.net https://puc.poecdn.net https://i.imgur.com https://wikimedia.org https://*.icons8.com https://*.giphy.com https://picsum.photos https://images.unsplash.com; frame-src 'self' https://www.youtube.com https://trytako.com; child-src 'self'; manifest-src 'self'; worker-src 'self'; upgrade-insecure-requests; block-all-mixed-content;">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>AV Game Changer - Broadcast Facility Control</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script>
        tailwind.config = {
            theme: {
                extend: {
                    colors: {
                        primary: '#5D5CDE',
                        'bg-light': '#FFFFFF', 
                        'bg-dark': '#181818'
                    },
                    fontFamily: {
                        'sans': ['Inter', 'system-ui', 'sans-serif'],
                    }
                }
            }
        }
    </script>
    <style>
        .tv-box {
            transition: all 0.3s ease;
        }
        .tv-assigned {
            background: #374151 !important;
            border-color: #4B5563 !important;
            color: white !important;
        }
        .tv-selected-for-copy {
            box-shadow: 0 0 35px #F59E0BA0 !important;
            border: 4px solid #F59E0B !important;
            transform: scale(1.1);
        }
        .tv-highlighted {
            box-shadow: 0 0 45px #5D5CDEE0 !important;
            border: 6px solid #5D5CDE !important;
            transform: scale(1.1);
        }
        .tv-box:hover {
            transform: scale(1.05);
            box-shadow: 0 4px 12px rgba(0,0,0,0.15);
        }
        .channel-row {
            transition: all 0.2s ease;
        }
        .channel-row:hover {
            background: rgba(93, 92, 222, 0.05);
        }
        .channel-selected {
            background: rgba(93, 92, 222, 0.1) !important;
            border-left: 4px solid #5D5CDE;
        }
    </style>
</head>

<body class="bg-bg-light dark:bg-bg-dark text-gray-900 dark:text-gray-100 min-h-screen pt-12">
    <!-- Header -->
    <header class="bg-white dark:bg-gray-800 shadow-lg border-b border-gray-200 dark:border-gray-700">
        <div class="max-w-full mx-auto px-4 py-3">
            <div class="flex items-center justify-between">
                <div class="flex items-center space-x-3">
                    <img src="https://pfst.cf2.poecdn.net/base/image/e40f84af7525742705f6b79f5f09f60a1c4af9be1835380f187579d6e0e9e0c7?w=498&amp;h=105" alt="NSAV Logo" class="h-8 w-auto object-contain bg-transparent">
                    <h1 class="text-xl font-bold text-gray-900 dark:text-white">AV GAME CHANGER</h1>
                </div>
                
                <!-- Status Message Area -->
                <div class="flex-1 flex justify-center">
                    <div id="status-message" class="px-4 py-1 text-sm font-semibold text-amber-700 dark:text-amber-300 bg-amber-100 dark:bg-amber-900/30 border border-amber-300 dark:border-amber-700 rounded-full hidden">
                        <!-- Status messages will appear here -->
                    </div>
                </div>
                <div class="flex items-center gap-12">
                    <!-- Preset Buttons Group -->
                    <div class="flex items-center space-x-4">
                        <button onmousedown="handlePresetMouseDown(1)" onmouseup="handlePresetMouseUp(1)" onmouseleave="handlePresetMouseUp(1)" ontouchstart="handlePresetTouchStart(1)" ontouchend="handlePresetTouchEnd(1)" class="px-3 py-1 text-xs bg-gray-100 text-gray-600 dark:bg-gray-700 dark:text-gray-400 rounded hover:bg-gray-200 dark:hover:bg-gray-600 transition-colors font-semibold">
                            Preset 1
                        </button>
                        <button onmousedown="handlePresetMouseDown(2)" onmouseup="handlePresetMouseUp(2)" onmouseleave="handlePresetMouseUp(2)" ontouchstart="handlePresetTouchStart(2)" ontouchend="handlePresetTouchEnd(2)" class="px-3 py-1 text-xs bg-gray-100 text-gray-600 dark:bg-gray-700 dark:text-gray-400 rounded hover:bg-gray-200 dark:hover:bg-gray-600 transition-colors font-semibold">
                            Preset 2
                        </button>
                        <button onmousedown="handlePresetMouseDown(3)" onmouseup="handlePresetMouseUp(3)" onmouseleave="handlePresetMouseUp(3)" ontouchstart="handlePresetTouchStart(3)" ontouchend="handlePresetTouchEnd(3)" class="px-3 py-1 text-xs bg-gray-100 text-gray-600 dark:bg-gray-700 dark:text-gray-400 rounded hover:bg-gray-200 dark:hover:bg-gray-600 transition-colors font-semibold">
                            Preset 3
                        </button>
                    </div>
                    
                    <!-- Utility Buttons Group -->
                    <div class="flex items-center space-x-4">
                        <button onclick="showHelp()" class="px-3 py-1 text-xs bg-gray-100 text-gray-600 dark:bg-gray-700 dark:text-gray-400 rounded hover:bg-gray-200 dark:hover:bg-gray-600 transition-colors">
                            üìñ Help
                        </button>
                    <div class="relative">
                        <button onclick="toggleAdminMenu()" id="admin-toggle" class="px-3 py-1 text-xs bg-gray-100 text-gray-600 dark:bg-gray-700 dark:text-gray-400 rounded hover:bg-gray-200 dark:hover:bg-gray-600 transition-colors">
                            üë§ Admin
                        </button>
                        <div id="admin-menu" class="absolute right-0 mt-1 w-48 bg-white dark:bg-gray-800 rounded-lg shadow-lg border border-gray-200 dark:border-gray-600 z-50 hidden">
                            <div class="py-2">
                                <button onclick="toggleAdminMode(); closeAdminMenu();" class="w-full text-left px-4 py-2 text-sm text-gray-700 dark:text-gray-300 hover:bg-gray-100 dark:hover:bg-gray-700">
                                    <span id="admin-mode-text">Enable Admin Mode</span>
                                </button>
                                <hr class="border-gray-200 dark:border-gray-600 my-1">
                                <button onclick="showTVSetup(); closeAdminMenu();" class="w-full text-left px-4 py-2 text-sm text-gray-700 dark:text-gray-300 hover:bg-gray-100 dark:hover:bg-gray-700">
                                    üì∫ TV Setup
                                </button>
                                <button onclick="toggleDebugMode(); closeAdminMenu();" class="w-full text-left px-4 py-2 text-sm text-gray-700 dark:text-gray-300 hover:bg-gray-100 dark:hover:bg-gray-700">
                                    <span id="debug-menu-text">Debug</span>
                                </button>
                                <button onclick="showPrefixManager(); closeAdminMenu();" class="w-full text-left px-4 py-2 text-sm text-gray-700 dark:text-gray-300 hover:bg-gray-100 dark:hover:bg-gray-700">
                                    ‚öôÔ∏è Manage Prefixes
                                </button>
                                <hr class="border-gray-200 dark:border-gray-600 my-1">
                                <button onclick="document.getElementById('floor-plan-upload').click(); closeAdminMenu();" class="w-full text-left px-4 py-2 text-sm text-gray-700 dark:text-gray-300 hover:bg-gray-100 dark:hover:bg-gray-700">
                                    üìÅ Load Floor Plan
                                </button>
                                <button onclick="toggleImageInvert(); closeAdminMenu();" id="admin-invert-btn" class="w-full text-left px-4 py-2 text-sm text-gray-700 dark:text-gray-300 hover:bg-gray-100 dark:hover:bg-gray-700">
                                    üîÑ Invert Image
                                </button>
                                <button onclick="showFloorPlanControls(); closeAdminMenu();" class="w-full text-left px-4 py-2 text-sm text-gray-700 dark:text-gray-300 hover:bg-gray-100 dark:hover:bg-gray-700">
                                    üìê Adjust Size
                                </button>
                                <button onclick="resetTVPositions(); closeAdminMenu();" class="w-full text-left px-4 py-2 text-sm text-gray-700 dark:text-gray-300 hover:bg-gray-100 dark:hover:bg-gray-700">
                                    üì∫ Reset TV Layout
                                </button>
                                <hr class="border-gray-200 dark:border-gray-600 my-1">
                                <button onclick="toggleDrawingMode(); closeAdminMenu();" class="w-full text-left px-4 py-2 text-sm text-gray-707 dark:text-gray-300 hover:bg-gray-100 dark:hover:bg-gray-700">
                                    <span id="drawing-menu-text">üé® Annotation Tools</span>
                                </button>
                                <hr class="border-gray-200 dark:border-gray-600 my-1">
                                <a href="mailto:gene@nostaticav.com?subject=AV Game Changer Support Request" onclick="closeAdminMenu();" class="w-full text-left px-4 py-2 text-sm text-gray-700 dark:text-gray-300 hover:bg-gray-100 dark:hover:bg-gray-700 block">
                                    üìß Email Support
                                </a>
                            </div>
                        </div>
                        <input type="file" id="floor-plan-upload" accept="image/*" class="hidden" onchange="loadFloorPlan(event)">
                    </div>
                    <button onclick="toggleColorMode()" id="color-toggle" class="px-3 py-1 text-xs bg-gray-100 text-gray-600 dark:bg-gray-700 dark:text-gray-400 rounded hover:bg-gray-200 dark:hover:bg-gray-600 transition-colors">
                        üé® Colors
                    </button>
                    <button onclick="showMessage('Save Feature', 'Auto-save will be implemented in production version.')" id="save-button" class="px-3 py-1 text-xs bg-gray-100 text-gray-600 dark:bg-gray-700 dark:text-gray-400 rounded hover:bg-gray-200 dark:hover:bg-gray-600 transition-colors">
                        üíæ Save
                    </button>
                    <div class="text-sm">
                        <span class="text-gray-500">Tuners:</span>
                        <span id="tuner-status" class="font-semibold text-green-600">0/23 Active</span>
                    </div>
                </div>
            </div>
        </div>
    </div></header>

    <div class="h-screen flex flex-col overflow-hidden">
        <div class="flex-1 flex gap-2 p-2 min-h-0">
            
            <!-- Floor Plan & TV Layout - Left Side -->
            <div class="flex-1 min-w-0">
                <div class="bg-white dark:bg-gray-800 rounded-xl shadow-lg p-3 flex flex-col" style="height: calc(100vh - 120px);">
                    <!-- Floor Plan Interactive View with TVs -->
                    <div class="bg-gray-50 dark:bg-gray-900 rounded-lg border-2 border-gray-300 dark:border-gray-600 overflow-auto flex-1">
                        <!-- Floor Plan Display Area with TVs -->
                        <div class="relative bg-black cursor-pointer overflow-hidden" id="floor-plan-workspace" onclick="handleWorkspaceClick(event)" style="width: 1700px; height: 1350px;">
                            <!-- Default Message -->
                            <div id="floor-plan-placeholder" class="absolute inset-0 flex items-center justify-center text-center text-gray-500 dark:text-gray-400 p-6 pointer-events-none">
                                <div>
                                    <div class="text-4xl mb-3">üì∫</div>
                                    <p class="text-base font-semibold mb-2">TV Control Grid</p>
                                    <p class="text-sm">Drag TVs to arrange layout</p>
                                    <p class="text-xs mt-3 italic">Click here to cancel any selection</p>
                                </div>
                            </div>
                            
                            <!-- Floor Plan Container (Background) -->
                            <div id="floor-plan-container" class="absolute inset-0 hidden">
                                <img id="floor-plan-image" class="block max-w-none transition-all duration-300 absolute cursor-move" draggable="false">
                            </div>
                            
                            <!-- TV Grid Overlay (Always Visible) -->
                            <div id="tv-grid" class="absolute inset-0 p-4 pointer-events-none" style="z-index: 10;">
                                <!-- TVs will be generated here as draggable elements -->
                            </div>
                        </div>
                    </div>
                </div>
            </div>

            <!-- Program Guide - Right Side -->
            <div class="w-96 flex-shrink-0">
                <div class="bg-white dark:bg-gray-800 rounded-xl shadow-lg flex flex-col" style="height: calc(100vh - 120px);">
                    <!-- Search and Filters -->
                    <div class="p-4 border-b border-gray-200 dark:border-gray-700 flex-shrink-0">
                        <div class="flex items-center justify-between mb-3">
                            <div class="flex items-center space-x-3">
                                <span class="text-lg font-semibold text-gray-900 dark:text-gray-100">Selected:</span>
                                
                                <!-- Channel Selection Display -->
                                <span id="header-selected-channel" class="text-lg font-bold text-primary hidden"></span>
                                
                                <!-- TV Copy Selection Display -->
                                <span id="header-selected-tv" class="text-lg font-bold text-orange-600 dark:text-orange-400 hidden"></span>
                                
                                <!-- Default State -->
                                <span id="header-no-selection" class="text-lg text-gray-500 dark:text-gray-400">None</span>
                            </div>
                        </div>
                        
                        <!-- Search -->
                        <div class="mb-3">
                            <input id="channel-search" type="text" placeholder="Search channels..." class="w-full px-3 py-2 text-base border border-gray-300 dark:border-gray-600 rounded-lg focus:ring-2 focus:ring-primary focus:border-transparent bg-white dark:bg-gray-700 text-gray-900 dark:text-gray-100" oninput="filterChannels()">
                        </div>
                        
                        <!-- Filter Buttons -->
                        <div class="flex flex-wrap gap-1">
                            <button onclick="setFilter('all')" id="filter-all" class="filter-btn px-3 py-1.5 text-xs font-medium rounded-lg transition-colors bg-gray-100 text-gray-700 dark:bg-gray-600 dark:text-gray-300 hover:bg-gray-200 dark:hover:bg-gray-500">
                                All
                            </button>
                            <button onclick="setFilter('sports')" id="filter-sports" class="filter-btn px-3 py-1.5 text-xs font-medium rounded-lg transition-colors bg-gray-100 text-gray-700 dark:bg-gray-600 dark:text-gray-300 hover:bg-gray-200 dark:hover:bg-gray-500">
                                Sports
                            </button>
                            <button onclick="setFilter('news')" id="filter-news" class="filter-btn px-3 py-1.5 text-xs font-medium rounded-lg transition-colors bg-gray-100 text-gray-700 dark:bg-gray-600 dark:text-gray-300 hover:bg-gray-200 dark:hover:bg-gray-500">
                                News
                            </button>

                        </div>
                        
                        <!-- Admin Mode Controls -->
                        <div id="admin-controls" class="mt-3 hidden">
                            <div class="flex flex-wrap gap-1">
                                <button onclick="setFilter('sd')" id="filter-sd" class="filter-btn px-3 py-1.5 text-xs font-medium rounded-lg transition-colors bg-gray-100 text-gray-700 dark:bg-gray-600 dark:text-gray-300 hover:bg-gray-200 dark:hover:bg-gray-500">
                                    üì∫ Show SD
                                </button>
                                <button onclick="hideAllSDChannels()" class="px-3 py-1.5 text-xs bg-red-100 text-red-700 dark:bg-red-900 dark:text-red-300 rounded-lg hover:bg-red-200 dark:hover:bg-red-800 transition-colors">
                                    üö´ Hide All SD
                                </button>
                            </div>
                        </div>
                    </div>

                    <!-- Channel List - Full Height -->
                    <div class="flex-1 overflow-y-auto">
                        <div id="channel-grid" class="divide-y divide-gray-200 dark:divide-gray-700">
                            <!-- Channels will be generated here -->
                        </div>
                        
                        <!-- Loading State -->
                        <div id="loading" class="text-center py-8">
                            <div class="animate-spin rounded-full h-8 w-8 border-b-2 border-primary mx-auto"></div>
                            <p class="text-gray-500 mt-2">Loading channels...</p>
                        </div>
                        
                        <!-- No Results -->
                        <div id="no-results" class="text-center py-8 hidden">
                            <p class="text-gray-500">No channels found matching your search.</p>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- Custom Modal -->
    <div id="custom-modal" class="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50 hidden">
        <div class="bg-white dark:bg-gray-800 p-6 rounded-lg shadow-xl max-w-sm w-full mx-4">
            <h3 id="modal-title" class="text-lg font-semibold mb-4"></h3>
            <p id="modal-message" class="text-gray-600 dark:text-gray-400 mb-4"></p>
            <div class="flex justify-end space-x-3">
                <button onclick="closeModal()" class="px-4 py-2 text-gray-600 dark:text-gray-400 hover:bg-gray-100 dark:hover:bg-gray-700 rounded">Cancel</button>
                <button onclick="closeModal()" class="px-4 py-2 bg-primary text-white hover:bg-primary/90 rounded">OK</button>
            </div>
        </div>
    </div>

    <!-- Prefix Manager Modal -->
    <div id="prefix-manager-modal" class="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50 hidden">
        <div class="bg-white dark:bg-gray-800 rounded-lg shadow-xl max-w-md w-full mx-4 max-h-[80vh] overflow-hidden flex flex-col">
            <!-- Header -->
            <div class="flex items-center justify-between p-6 border-b border-gray-200 dark:border-gray-700">
                <h3 class="text-lg font-semibold text-gray-900 dark:text-gray-100">Manage Program Prefixes</h3>
                <button onclick="closePrefixManager()" class="text-gray-400 hover:text-gray-600 dark:hover:text-gray-300">
                    <span class="text-xl">‚úï</span>
                </button>
            </div>
            
            <!-- Content -->
            <div class="flex-1 overflow-y-auto p-6">
                <!-- Info -->
                <div class="bg-blue-50 dark:bg-blue-900/20 border border-blue-200 dark:border-blue-800 rounded-lg p-4 mb-6">
                    <div class="flex items-start space-x-3">
                        <span class="text-blue-600 dark:text-blue-400 text-lg">‚ÑπÔ∏è</span>
                        <div class="text-sm text-blue-800 dark:text-blue-200">
                            <p class="font-medium mb-1">Add prefixes that will be automatically removed from program titles on TV displays.</p>
                            <p>For example, adding "NBA Basketball:" will show "Lakers vs Warriors" instead of "NBA Basketball: Lakers vs Warriors" on TVs.</p>
                        </div>
                    </div>
                </div>
                
                <!-- Add New Prefix -->
                <div class="mb-6">
                    <label class="block text-sm font-medium text-gray-700 dark:text-gray-300 mb-2">Add New Prefix</label>
                    <div class="flex space-x-2">
                        <input id="new-prefix-input" type="text" placeholder="e.g. 'NBA Basketball:' or 'College Football:'" class="flex-1 px-3 py-2 border border-gray-300 dark:border-gray-600 rounded-lg focus:ring-2 focus:ring-primary focus:border-transparent bg-white dark:bg-gray-700 text-gray-900 dark:text-gray-100 text-sm" onkeypress="handlePrefixKeyPress(event)">
                        <button onclick="addNewPrefix()" class="px-4 py-2 bg-primary text-white rounded-lg hover:bg-primary/90 transition-colors text-sm font-medium">
                            + Add
                        </button>
                    </div>
                </div>
                
                <!-- Current Prefixes -->
                <div>
                    <label class="block text-sm font-medium text-gray-700 dark:text-gray-300 mb-3">Current Prefixes</label>
                    <div id="prefix-list" class="space-y-2 max-h-60 overflow-y-auto">
                        <!-- Prefixes will be rendered here -->
                    </div>
                </div>
            </div>
            
            <!-- Footer -->
            <div class="flex justify-between p-6 border-t border-gray-200 dark:border-gray-700">
                <button onclick="resetPrefixesToDefault()" class="px-4 py-2 text-gray-600 dark:text-gray-400 hover:bg-gray-100 dark:hover:bg-gray-700 rounded-lg transition-colors text-sm font-medium">
                    üîÑ Reset to Defaults
                </button>
                <button onclick="savePrefixChanges()" class="px-6 py-2 bg-green-600 text-white rounded-lg hover:bg-green-700 transition-colors text-sm font-medium">
                    üíæ Save Changes
                </button>
            </div>
        </div>
    </div>

    <!-- TV Setup Modal -->
    <div id="tv-setup-modal" class="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50 hidden">
        <div class="bg-white dark:bg-gray-800 rounded-lg shadow-xl max-w-4xl w-full mx-4 max-h-[90vh] overflow-hidden flex flex-col">
            <!-- Header -->
            <div class="flex items-center justify-between p-6 border-b border-gray-200 dark:border-gray-700">
                <h3 class="text-xl font-semibold text-gray-900 dark:text-gray-100">üì∫ TV Setup Configuration</h3>
                <button onclick="closeTVSetup()" class="text-gray-400 hover:text-gray-600 dark:hover:text-gray-300">
                    <span class="text-xl">‚úï</span>
                </button>
            </div>
            
            <!-- Content -->
            <div class="flex-1 overflow-y-auto p-6">
                <!-- Network Info -->
                <div class="bg-blue-50 dark:bg-blue-900/20 border border-blue-200 dark:border-blue-800 rounded-lg p-4 mb-6">
                    <div class="flex items-start space-x-3">
                        <span class="text-blue-600 dark:text-blue-400 text-lg">üåê</span>
                        <div class="text-sm text-blue-800 dark:text-blue-200">
                            <p class="font-medium mb-2">Network Configuration (Standard)</p>
                            <div class="grid grid-cols-2 gap-4">
                                <div>
                                    <strong>Router:</strong> 192.168.3.1<br>
                                    <strong>COM Headend:</strong> 192.168.3.18
                                </div>
                                <div>
                                    <strong>STB Range:</strong> 192.168.3.101-132<br>
                                    <strong>Max TVs:</strong> 32 (using STB-6500s)
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
                
                <!-- TV Count Configuration -->
                <div class="mb-6">
                    <label class="block text-lg font-medium text-gray-700 dark:text-gray-300 mb-3">Number of TVs in This Installation</label>
                    <div class="flex items-center space-x-4 mb-4">
                        <input id="tv-count-input" type="number" min="1" max="100" value="24" class="w-24 px-3 py-2 border border-gray-300 dark:border-gray-600 rounded-lg focus:ring-2 focus:ring-primary focus:border-transparent bg-white dark:bg-gray-700 text-gray-900 dark:text-gray-100 text-base text-center font-bold" onchange="updateTVConfiguration()">
                        <span class="text-sm text-gray-600 dark:text-gray-400">TVs (1-100 max)</span>
                        <button onclick="applyTVCount()" class="px-6 py-2 bg-primary text-white rounded-lg hover:bg-primary/90 transition-colors text-sm font-medium">
                            üîß Apply Configuration
                        </button>
                    </div>
                </div>

                <!-- IP Assignment Table -->
                <div>
                    <label class="block text-lg font-medium text-gray-700 dark:text-gray-300 mb-3">STB-6500 IP Address Assignments</label>
                    <div class="bg-gray-50 dark:bg-gray-900 rounded-lg p-4 border border-gray-200 dark:border-gray-700">
                        <div class="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 xl:grid-cols-4 gap-3" id="ip-assignments">
                            <!-- IP assignments will be generated here -->
                        </div>
                    </div>
                </div>
                
                <!-- Setup Instructions -->
                <div class="mt-6 bg-amber-50 dark:bg-amber-900/20 border border-amber-200 dark:border-amber-800 rounded-lg p-4">
                    <div class="flex items-start space-x-3">
                        <span class="text-amber-600 dark:text-amber-400 text-lg">‚öôÔ∏è</span>
                        <div class="text-sm text-amber-800 dark:text-amber-200">
                            <p class="font-medium mb-2">STB-6500 Setup Instructions:</p>
                            <ol class="list-decimal list-inside space-y-1">
                                <li>Connect each STB-6500 to the network</li>
                                <li>Run the built-in setup on each decoder</li>
                                <li>Assign the matching IP address from the table above</li>
                                <li>Configure subnet mask: 255.255.255.0</li>
                                <li>Configure gateway: 192.168.3.1</li>
                                <li>Test connectivity and you're ready to go!</li>
                            </ol>
                        </div>
                    </div>
                </div>
            </div>
            
            <!-- Footer -->
            <div class="flex justify-between p-6 border-t border-gray-200 dark:border-gray-700">
                <button onclick="exportConfiguration()" class="px-4 py-2 text-gray-600 dark:text-gray-400 hover:bg-gray-100 dark:hover:bg-gray-700 rounded-lg transition-colors text-sm font-medium">
                    üìã Export Config
                </button>
                <button onclick="saveTVConfiguration()" class="px-6 py-2 bg-green-600 text-white rounded-lg hover:bg-green-700 transition-colors text-sm font-medium">
                    üíæ Save &amp; Apply
                </button>
            </div>
        </div>
    </div>

    <!-- Color Picker Modal -->
    <div id="color-picker-modal" class="absolute z-50 hidden" style="top: 124px; right: 10px; width: 384px;">
        <div class="bg-white dark:bg-gray-800 rounded-lg shadow-xl border-2 border-primary m-2">
            <!-- Color Grid -->
            <div class="p-6">
                <div class="grid grid-cols-5 gap-3" id="color-grid">
                    <!-- Colors will be generated here -->
                </div>
            </div>
        </div>
    </div>

    <!-- Floor Plan Controls Modal -->
    <div id="floor-plan-controls-modal" class="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50 hidden">
        <div class="bg-white dark:bg-gray-800 rounded-lg shadow-xl max-w-md w-full mx-4">
            <!-- Header -->
            <div class="flex items-center justify-between p-6 border-b border-gray-200 dark:border-gray-700">
                <h3 class="text-lg font-semibold text-gray-900 dark:text-gray-100">üìê Floor Plan Size Controls</h3>
                <button onclick="closeFloorPlanControls()" class="text-gray-400 hover:text-gray-600 dark:hover:text-gray-300">
                    <span class="text-xl">‚úï</span>
                </button>
            </div>
            
            <!-- Content -->
            <div class="p-6">
                <!-- Image Inversion -->
                <div class="mb-6">
                    <label class="block text-sm font-medium text-gray-700 dark:text-gray-300 mb-3">Image Display</label>
                    <div class="flex items-center space-x-4">
                        <button onclick="toggleImageInvert()" id="invert-control-btn" class="px-4 py-2 bg-gray-100 text-gray-700 dark:bg-gray-700 dark:text-gray-300 rounded-lg hover:bg-gray-200 dark:hover:bg-gray-600 transition-colors text-sm">
                            üîÑ Toggle Invert
                        </button>
                        <span class="text-xs text-gray-500 dark:text-gray-400">Convert black/white colors</span>
                    </div>
                </div>
                
                <!-- Image Sizing -->
                <div class="mb-6">
                    <label class="block text-sm font-medium text-gray-700 dark:text-gray-300 mb-3">Image Size</label>
                    <div class="space-y-3">
                        <div class="flex items-center space-x-3">
                            <label class="text-sm text-gray-600 dark:text-gray-400 w-16">Width:</label>
                            <input id="image-width" type="number" min="100" max="2000" value="1000" class="flex-1 px-3 py-1 border border-gray-300 dark:border-gray-600 rounded text-sm bg-white dark:bg-gray-700 text-gray-900 dark:text-gray-100" onchange="updateImageSize()">
                            <span class="text-xs text-gray-500">px</span>
                        </div>
                        <div class="flex items-center space-x-3">
                            <label class="text-sm text-gray-600 dark:text-gray-400 w-16">Height:</label>
                            <input id="image-height" type="number" min="100" max="2000" value="800" class="flex-1 px-3 py-1 border border-gray-300 dark:border-gray-600 rounded text-sm bg-white dark:bg-gray-700 text-gray-900 dark:text-gray-100" onchange="updateImageSize()">
                            <span class="text-xs text-gray-500">px</span>
                        </div>
                        <div class="flex items-center space-x-3">
                            <label class="flex items-center space-x-2">
                                <input type="checkbox" id="maintain-aspect" checked="" onchange="updateImageSize()">
                                <span class="text-sm text-gray-600 dark:text-gray-400">Maintain aspect ratio</span>
                            </label>
                        </div>
                    </div>
                </div>
                
                <!-- Quick Size Presets -->
                <div class="mb-4">
                    <label class="block text-sm font-medium text-gray-700 dark:text-gray-300 mb-3">Quick Presets</label>
                    <div class="grid grid-cols-2 gap-2">
                        <button onclick="setImageSize(800, 600)" class="px-3 py-2 text-xs bg-blue-100 text-blue-700 dark:bg-blue-900 dark:text-blue-300 rounded hover:bg-blue-200 dark:hover:bg-blue-800 transition-colors">800√ó600</button>
                        <button onclick="setImageSize(1000, 800)" class="px-3 py-2 text-xs bg-blue-100 text-blue-700 dark:bg-blue-900 dark:text-blue-300 rounded hover:bg-blue-200 dark:hover:bg-blue-800 transition-colors">1000√ó800</button>
                        <button onclick="setImageSize(1200, 900)" class="px-3 py-2 text-xs bg-blue-100 text-blue-700 dark:bg-blue-900 dark:text-blue-300 rounded hover:bg-blue-200 dark:hover:bg-blue-800 transition-colors">1200√ó900</button>
                        <button onclick="resetImageSize()" class="px-3 py-2 text-xs bg-gray-100 text-gray-600 dark:bg-gray-700 dark:text-gray-400 rounded hover:bg-gray-200 dark:hover:bg-gray-600 transition-colors">Reset</button>
                    </div>
                </div>
            </div>
            
            <!-- Footer -->
            <div class="flex justify-end p-6 border-t border-gray-200 dark:border-gray-700">
                <button onclick="closeFloorPlanControls()" class="px-6 py-2 bg-primary text-white rounded-lg hover:bg-primary/90 transition-colors text-sm font-medium">
                    Done
                </button>
            </div>
        </div>
    </div>

    <!-- Drawing Tools Dropdown Panel -->
    <div id="drawing-tools-panel" class="absolute z-50 hidden" style="top: 115px; right: 10px; width: 384px;">
        <div class="bg-white dark:bg-gray-800 rounded-lg shadow-xl border-2 border-primary m-2">
            <!-- Header -->
            <div class="flex items-center justify-between p-4 border-b border-gray-200 dark:border-gray-700">
                <h3 class="text-lg font-semibold text-gray-900 dark:text-gray-100">üé® Annotation Tools</h3>
                <button onclick="closeDrawingTools()" class="text-gray-400 hover:text-gray-600 dark:hover:text-gray-300">
                    <span class="text-xl">‚úï</span>
                </button>
            </div>
            
            <!-- Content -->
            <div class="p-4">
                <!-- Text Tool (Top Section - Most Used) -->
                <div class="mb-6 p-3 bg-gray-50 dark:bg-gray-900/50 rounded-lg border border-gray-200 dark:border-gray-600">
                    <label class="block text-sm font-medium text-gray-700 dark:text-gray-300 mb-3">üìù Text Labels</label>
                    <div class="space-y-3">
                        <!-- Text Input -->
                        <div class="flex space-x-2">
                            <input id="text-input" type="text" placeholder="Enter text..." class="flex-1 px-3 py-2 border border-gray-300 dark:border-gray-600 rounded-lg focus:ring-2 focus:ring-primary focus:border-transparent bg-white dark:bg-gray-700 text-gray-900 dark:text-gray-100 text-sm" onkeypress="handleQuickTextKeyPress(event)" maxlength="50">
                            <button onclick="insertQuickTextLabel()" class="px-4 py-2 bg-primary text-white rounded-lg hover:bg-primary/90 transition-colors text-sm font-medium">
                                Add
                            </button>
                        </div>
                        <!-- Font Size -->
                        <div>
                            <label class="block text-xs text-gray-600 dark:text-gray-400 mb-1">Size</label>
                            <select id="text-size" class="w-full px-2 py-1 border border-gray-300 dark:border-gray-600 rounded text-sm bg-white dark:bg-gray-700 text-gray-900 dark:text-gray-100">
                                <option value="text-xs">Small</option>
                                <option value="text-sm">Medium</option>
                                <option value="text-base" selected="">Normal</option>
                                <option value="text-lg">Large</option>
                                <option value="text-xl">Extra Large</option>
                            </select>
                        </div>
                    </div>
                </div>
                
                <!-- Drawing Tools Section -->
                <div class="mb-4">
                    <label class="block text-sm font-medium text-gray-700 dark:text-gray-300 mb-2">Drawing Tool</label>
                    <div class="grid grid-cols-3 gap-2">
                        <button onclick="selectDrawingTool('line')" id="tool-line" class="drawing-tool-btn p-3 border border-gray-300 dark:border-gray-600 rounded-lg hover:bg-gray-50 dark:hover:bg-gray-700 text-center">
                            <div class="text-2xl mb-1">üìè</div>
                            <div class="text-xs">Line</div>
                        </button>
                        <button onclick="selectDrawingTool('rectangle')" id="tool-rectangle" class="drawing-tool-btn p-3 border border-gray-300 dark:border-gray-600 rounded-lg hover:bg-gray-50 dark:hover:bg-gray-700 text-center">
                            <div class="text-2xl mb-1">‚¨ú</div>
                            <div class="text-xs">Rectangle</div>
                        </button>
                        <button onclick="selectDrawingTool('circle')" id="tool-circle" class="drawing-tool-btn p-3 border border-gray-300 dark:border-gray-600 rounded-lg hover:bg-gray-50 dark:hover:bg-gray-700 text-center">
                            <div class="text-2xl mb-1">‚≠ï</div>
                            <div class="text-xs">Circle</div>
                        </button>
                    </div>
                </div>
                
                <!-- Shared Color Selection -->
                <div class="mb-4">
                    <label class="block text-sm font-medium text-gray-700 dark:text-gray-300 mb-2">Color</label>
                    <div class="grid grid-cols-6 gap-2">
                        <button onclick="setSharedColor('white')" id="color-white" class="w-8 h-8 bg-white border-2 border-gray-300 rounded" title="White"></button>
                        <button onclick="setSharedColor('red')" id="color-red" class="w-8 h-8 bg-red-500 rounded" title="Red"></button>
                        <button onclick="setSharedColor('blue')" id="color-blue" class="w-8 h-8 bg-blue-500 rounded" title="Blue"></button>
                        <button onclick="setSharedColor('green')" id="color-green" class="w-8 h-8 bg-green-500 rounded" title="Green"></button>
                        <button onclick="setSharedColor('yellow')" id="color-yellow" class="w-8 h-8 bg-yellow-400 rounded" title="Yellow"></button>
                        <button onclick="setSharedColor('purple')" id="color-purple" class="w-8 h-8 bg-purple-500 rounded" title="Purple"></button>
                    </div>
                </div>
                
                <!-- Style Options -->
                <div class="mb-4">
                    <label class="block text-sm font-medium text-gray-700 dark:text-gray-300 mb-2">Style</label>
                    <div class="grid grid-cols-2 gap-3">
                        <div>
                            <label class="block text-xs text-gray-600 dark:text-gray-400 mb-1">Line Width</label>
                            <select id="line-width" class="w-full px-2 py-1 border border-gray-300 dark:border-gray-600 rounded text-sm bg-white dark:bg-gray-700 text-gray-900 dark:text-gray-100">
                                <option value="1">Thin (1px)</option>
                                <option value="2" selected="">Normal (2px)</option>
                                <option value="3">Thick (3px)</option>
                                <option value="4">Extra Thick (4px)</option>
                            </select>
                        </div>
                        <div>
                            <label class="block text-xs text-gray-600 dark:text-gray-400 mb-1">Fill Style</label>
                            <select id="fill-style" class="w-full px-2 py-1 border border-gray-300 dark:border-gray-600 rounded text-sm bg-white dark:bg-gray-700 text-gray-900 dark:text-gray-100">
                                <option value="none" selected="">Outline Only</option>
                                <option value="solid">Solid Fill</option>
                                <option value="transparent">Transparent Fill</option>
                            </select>
                        </div>
                    </div>
                </div>
                
                <!-- Action Buttons -->
                <div class="flex justify-between">
                    <button onclick="clearAllAnnotations()" class="px-3 py-2 text-red-600 dark:text-red-400 hover:bg-red-50 dark:hover:bg-red-900/20 rounded transition-colors text-sm">üóëÔ∏è Clear All</button>
                    <button onclick="closeDrawingTools()" class="px-4 py-2 bg-primary text-white rounded hover:bg-primary/90 transition-colors text-sm">‚úï Close Tools</button>
                </div>
            </div>
        </div>
    </div>

    <!-- Text Insertion Modal -->
    <div id="text-insertion-modal" class="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50 hidden">
        <div class="bg-white dark:bg-gray-800 rounded-lg shadow-xl max-w-md w-full mx-4">
            <!-- Header -->
            <div class="flex items-center justify-between p-6 border-b border-gray-200 dark:border-gray-700">
                <h3 class="text-lg font-semibold text-gray-900 dark:text-gray-100">üìù Insert Text Label</h3>
                <button onclick="closeTextInsertion()" class="text-gray-400 hover:text-gray-600 dark:hover:text-gray-300">
                    <span class="text-xl">‚úï</span>
                </button>
            </div>
            
            <!-- Content -->
            <div class="p-6">
                <p class="text-sm text-gray-600 dark:text-gray-400 mb-4">Add a text label to your floor plan. You can drag it to position after insertion.</p>
                
                <!-- Text Input -->
                <div class="mb-4">
                    <label class="block text-sm font-medium text-gray-700 dark:text-gray-300 mb-2">Label Text</label>
                    <input id="text-label-input" type="text" placeholder="e.g. 'Bar Area', 'Main Dining', 'VIP Section'" class="w-full px-3 py-2 border border-gray-300 dark:border-gray-600 rounded-lg focus:ring-2 focus:ring-primary focus:border-transparent bg-white dark:bg-gray-700 text-gray-900 dark:text-gray-100 text-base" onkeypress="handleTextKeyPress(event)" maxlength="50">
                </div>
                
                <!-- Font Size -->
                <div class="mb-4">
                    <label class="block text-sm font-medium text-gray-700 dark:text-gray-300 mb-2">Font Size</label>
                    <select id="text-size-select" class="w-full px-3 py-2 border border-gray-300 dark:border-gray-600 rounded-lg bg-white dark:bg-gray-700 text-gray-900 dark:text-gray-100">
                        <option value="text-xs">Small</option>
                        <option value="text-sm">Medium</option>
                        <option value="text-base" selected="">Normal</option>
                        <option value="text-lg">Large</option>
                        <option value="text-xl">Extra Large</option>
                    </select>
                </div>
                
                <!-- Text Color -->
                <div class="mb-6">
                    <label class="block text-sm font-medium text-gray-700 dark:text-gray-300 mb-2">Text Color</label>
                    <div class="grid grid-cols-6 gap-2">
                        <button onclick="setTextColor('white')" class="w-8 h-8 bg-white border-2 border-gray-300 rounded" title="White"></button>
                        <button onclick="setTextColor('yellow')" class="w-8 h-8 bg-yellow-400 rounded" title="Yellow"></button>
                        <button onclick="setTextColor('red')" class="w-8 h-8 bg-red-500 rounded" title="Red"></button>
                        <button onclick="setTextColor('blue')" class="w-8 h-8 bg-blue-500 rounded" title="Blue"></button>
                        <button onclick="setTextColor('green')" class="w-8 h-8 bg-green-500 rounded" title="Green"></button>
                        <button onclick="setTextColor('purple')" class="w-8 h-8 bg-purple-500 rounded" title="Purple"></button>
                    </div>
                </div>
            </div>
            
            <!-- Footer -->
            <div class="flex justify-end space-x-3 p-6 border-t border-gray-200 dark:border-gray-700">
                <button onclick="closeTextInsertion()" class="px-4 py-2 text-gray-600 dark:text-gray-400 hover:bg-gray-100 dark:hover:bg-gray-700 rounded transition-colors">Cancel</button>
                <button onclick="insertTextLabel()" class="px-6 py-2 bg-primary text-white rounded hover:bg-primary/90 transition-colors">Insert Text</button>
            </div>
        </div>
    </div>

    <!-- Onboarding Tour Modal -->
    <div id="onboarding-tour" class="fixed inset-0 bg-black bg-opacity-80 flex items-center justify-center z-[100] hidden">
        <div class="bg-white dark:bg-gray-800 rounded-lg shadow-xl max-w-2xl w-full mx-4 max-h-[90vh] overflow-hidden flex flex-col">
            <!-- Header -->
            <div class="flex items-center justify-between p-6 border-b border-gray-200 dark:border-gray-700 bg-gradient-to-r from-primary to-blue-600 text-white">
                <div>
                    <h2 class="text-2xl font-bold">üéâ Welcome to AV Game Changer</h2>
                    <p class="text-blue-100">Professional Edition - Let's show you around!</p>
                </div>
                <button onclick="skipTour()" class="text-blue-200 hover:text-white transition-colors">
                    <span class="text-xl">‚úï</span>
                </button>
            </div>
            
            <!-- Tour Content -->
            <div class="flex-1 overflow-y-auto p-6">
                <div id="tour-step-content">
                    <!-- Tour steps will be injected here -->
                </div>
            </div>
            
            <!-- Tour Navigation -->
            <div class="flex items-center justify-between p-6 border-t border-gray-200 dark:border-gray-700 bg-gray-50 dark:bg-gray-900">
                <div class="flex items-center space-x-3">
                    <span class="text-sm text-gray-600 dark:text-gray-400">Step <span id="tour-current-step">1</span> of <span id="tour-total-steps">6</span></span>
                    <div class="flex space-x-1">
                        <div class="tour-dot w-2 h-2 rounded-full bg-primary"></div>
                        <div class="tour-dot w-2 h-2 rounded-full bg-gray-300 dark:bg-gray-600"></div>
                        <div class="tour-dot w-2 h-2 rounded-full bg-gray-300 dark:bg-gray-600"></div>
                        <div class="tour-dot w-2 h-2 rounded-full bg-gray-300 dark:bg-gray-600"></div>
                        <div class="tour-dot w-2 h-2 rounded-full bg-gray-300 dark:bg-gray-600"></div>
                        <div class="tour-dot w-2 h-2 rounded-full bg-gray-300 dark:bg-gray-600"></div>
                    </div>
                </div>
                <div class="flex space-x-3">
                    <button onclick="previousTourStep()" id="tour-prev-btn" class="px-4 py-2 text-gray-600 dark:text-gray-400 hover:bg-gray-100 dark:hover:bg-gray-700 rounded disabled:opacity-50" disabled="">Previous</button>
                    <button onclick="nextTourStep()" id="tour-next-btn" class="px-6 py-2 bg-primary text-white rounded hover:bg-primary/90 transition-colors">Next</button>
                    <button onclick="skipTour()" id="tour-finish-btn" class="px-6 py-2 bg-green-600 text-white rounded hover:bg-green-700 transition-colors hidden">Start Using AV Game Changer!</button>
                </div>
            </div>
        </div>
    </div>

    <!-- Tour Highlight Overlay -->
    <div id="tour-highlight" class="fixed pointer-events-none z-[90] hidden">
        <div class="absolute border-4 border-yellow-400 rounded-lg shadow-lg animate-pulse"></div>
        <div class="absolute -top-8 left-0 bg-yellow-400 text-black px-3 py-1 rounded text-sm font-semibold whitespace-nowrap">üëÜ Check this out!</div>
    </div>

    <!-- Preset Recall Confirmation Modal -->
    <div id="preset-recall-modal" class="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50 hidden">
        <div class="bg-white dark:bg-gray-800 p-6 rounded-lg shadow-xl max-w-sm w-full mx-4">
            <h3 id="preset-modal-title" class="text-lg font-semibold mb-4 text-gray-900 dark:text-gray-100">Recall Preset 1?</h3>
            <p class="text-gray-600 dark:text-gray-400 mb-4">This will apply the saved TV channel assignments from this preset.</p>
            <div class="flex justify-end space-x-3">
                <button onclick="cancelPresetRecall()" class="px-4 py-2 text-gray-600 dark:text-gray-400 hover:bg-gray-100 dark:hover:bg-gray-700 rounded">No</button>
                <button onclick="confirmPresetRecall()" class="px-4 py-2 bg-primary text-white hover:bg-primary/90 rounded">Yes</button>
            </div>
        </div>
    </div>

    <!-- Help Modal -->
    <div id="help-modal" class="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50 hidden">
        <div class="bg-white dark:bg-gray-800 rounded-lg shadow-xl max-w-4xl w-full mx-4 max-h-[90vh] overflow-hidden flex flex-col">
            <!-- Header -->
            <div class="flex items-center justify-between p-6 border-b border-gray-200 dark:border-gray-700">
                <h3 class="text-xl font-semibold text-gray-900 dark:text-gray-100">üìñ AV Game Changer - Help &amp; Operations</h3>
                <button onclick="closeHelp()" class="text-gray-400 hover:text-gray-600 dark:hover:text-gray-300">
                    <span class="text-xl">‚úï</span>
                </button>
            </div>
            
            <!-- Content -->
            <div class="flex-1 overflow-y-auto p-6">
                <!-- Quick Actions -->
                <div class="mb-6">
                    <h4 class="text-lg font-semibold text-gray-900 dark:text-gray-100 mb-4">üéØ Quick Actions</h4>
                    <div class="grid grid-cols-1 md:grid-cols-3 gap-4">
                        <button onclick="applyPreset('gamenight'); closeHelp();" class="p-4 bg-gray-50 dark:bg-gray-900/20 border border-gray-200 dark:border-gray-700 rounded-lg hover:bg-gray-100 dark:hover:bg-gray-800/30 transition-colors text-left">
                            <div class="flex items-center space-x-3">
                                <span class="text-2xl">üèà</span>
                                <div>
                                    <div class="font-semibold text-gray-700 dark:text-gray-300">Game Night Preset</div>
                                    <div class="text-sm text-gray-600 dark:text-gray-400">Auto-assign sports channels to TVs 1-8</div>
                                </div>
                            </div>
                        </button>
                        
                        <button onclick="saveSystemState(true); closeHelp();" class="p-4 bg-gray-50 dark:bg-gray-900/20 border border-gray-200 dark:border-gray-700 rounded-lg hover:bg-gray-100 dark:hover:bg-gray-800/30 transition-colors text-left">
                            <div class="flex items-center space-x-3">
                                <span class="text-2xl">üíæ</span>
                                <div>
                                    <div class="font-semibold text-gray-700 dark:text-gray-300">Save Current State</div>
                                    <div class="text-sm text-gray-600 dark:text-gray-400">Manually save all assignments and settings</div>
                                </div>
                            </div>
                        </button>
                        
                        <button onclick="startOnboardingTour(); closeHelp();" class="p-4 bg-gray-50 dark:bg-gray-900/20 border border-gray-200 dark:border-gray-700 rounded-lg hover:bg-gray-100 dark:hover:bg-gray-800/30 transition-colors text-left">
                            <div class="flex items-center space-x-3">
                                <span class="text-2xl">üéì</span>
                                <div>
                                    <div class="font-semibold text-gray-700 dark:text-gray-300">Welcome Tutorial</div>
                                    <div class="text-sm text-gray-600 dark:text-gray-400">Rerun the interactive walkthrough</div>
                                </div>
                            </div>
                        </button>
                        
                        <button onclick="openSupportBot(); closeHelp();" class="p-4 bg-gray-50 dark:bg-gray-900/20 border border-gray-200 dark:border-gray-700 rounded-lg hover:bg-gray-100 dark:hover:bg-gray-800/30 transition-colors text-left">
                            <div class="flex items-center space-x-3">
                                <span class="text-2xl">üéß</span>
                                <div>
                                    <div class="font-semibold text-gray-700 dark:text-gray-300">Tech Support</div>
                                    <div class="text-sm text-gray-600 dark:text-gray-400">AI chat support powered by NSAV expertise</div>
                                </div>
                            </div>
                        </button>
                        
                        <button onclick="exportDemoPackage(); closeHelp();" class="p-4 bg-purple-50 dark:bg-purple-900/20 border border-purple-200 dark:border-purple-700 rounded-lg hover:bg-purple-100 dark:hover:bg-purple-800/30 transition-colors text-left">
                            <div class="flex items-center space-x-3">
                                <span class="text-2xl">üì¶</span>
                                <div>
                                    <div class="font-semibold text-purple-700 dark:text-purple-300">Export Demo Package</div>
                                    <div class="text-sm text-purple-600 dark:text-purple-400">Create shareable demo with current state baked in</div>
                                </div>
                            </div>
                        </button>
                        
                        <button onclick="showConfirmClearAll(); closeHelp();" class="p-4 bg-gray-50 dark:bg-gray-900/20 border border-gray-200 dark:border-gray-700 rounded-lg hover:bg-gray-100 dark:hover:bg-gray-800/30 transition-colors text-left">
                            <div class="flex items-center space-x-3">
                                <span class="text-2xl">üóëÔ∏è</span>
                                <div>
                                    <div class="font-semibold text-gray-700 dark:text-gray-300">Clear All TVs</div>
                                    <div class="text-sm text-gray-600 dark:text-gray-400">Reset all TV assignments to clear state</div>
                                </div>
                            </div>
                        </button>
                    </div>
                </div>

                <!-- Core Operations -->
                <div class="mb-6">
                    <h4 class="text-lg font-semibold text-gray-900 dark:text-gray-100 mb-4">üì∫ Core Operations</h4>
                    
                    <!-- Channel Assignment -->
                    <div class="mb-4 p-4 bg-gray-50 dark:bg-gray-900/20 border border-gray-200 dark:border-gray-700 rounded-lg">
                        <h5 class="font-semibold text-gray-700 dark:text-gray-300 mb-2">Channel ‚Üí TV Assignment</h5>
                        <ol class="list-decimal list-inside space-y-1 text-sm text-gray-600 dark:text-gray-400">
                            <li>Click channel card ‚Üí blue highlights on matching TVs</li>
                            <li>Click TV(s) to assign ‚Üí immediate update</li>
                            <li>Multiple TV assignment from single selection</li>
                            <li>5-second auto-expire or click floor plan to cancel</li>
                        </ol>
                    </div>

                    <!-- TV Copying -->
                    <div class="mb-4 p-4 bg-gray-50 dark:bg-gray-900/20 border border-gray-200 dark:border-gray-700 rounded-lg">
                        <h5 class="font-semibold text-gray-700 dark:text-gray-300 mb-2">TV ‚Üí TV Copying</h5>
                        <ol class="list-decimal list-inside space-y-1 text-sm text-gray-600 dark:text-gray-400">
                            <li>Click assigned TV ‚Üí orange highlight for copy mode</li>
                            <li>Click target TV(s) ‚Üí copies channel instantly</li>
                            <li>Multi-target copying from single source</li>
                            <li>Efficient channel distribution workflow</li>
                        </ol>
                    </div>
                </div>

                <!-- System Features -->
                <div class="mb-6">
                    <h4 class="text-lg font-semibold text-gray-900 dark:text-gray-100 mb-4">‚öôÔ∏è System Features</h4>
                    
                    <div class="grid grid-cols-1 md:grid-cols-2 gap-4">
                        <!-- Search & Filtering -->
                        <div class="p-4 bg-gray-50 dark:bg-gray-900/20 border border-gray-200 dark:border-gray-700 rounded-lg">
                            <h5 class="font-semibold text-gray-700 dark:text-gray-300 mb-2">üîç Search &amp; Filtering</h5>
                            <ul class="list-disc list-inside space-y-1 text-sm text-gray-600 dark:text-gray-400">
                                <li>Search: Channel names, numbers, programs</li>
                                <li>Filters: All, Sports, News</li>
                                <li>Dynamic sport filters (Football, Basketball, Baseball)</li>
                                <li>SD channel visibility toggle</li>
                            </ul>
                        </div>

                        <!-- Tuner Management -->
                        <div class="p-4 bg-gray-50 dark:bg-gray-900/20 border border-gray-200 dark:border-gray-700 rounded-lg">
                            <h5 class="font-semibold text-gray-700 dark:text-gray-300 mb-2">üì° Tuner Management</h5>
                            <ul class="list-disc list-inside space-y-1 text-sm text-gray-600 dark:text-gray-400">
                                <li>23 available tuners with intelligent sharing</li>
                                <li>Multiple TVs per tuner (same channel)</li>
                                <li>Automatic allocation/cleanup</li>
                                <li>Real-time status: X/23 Active</li>
                            </ul>
                        </div>
                    </div>
                </div>

                <!-- Advanced Features -->
                <div class="mb-6">
                    <h4 class="text-lg font-semibold text-gray-900 dark:text-gray-100 mb-4">üîß Advanced Features</h4>
                    
                    <!-- Floor Plan System -->
                    <div class="mb-4 p-4 bg-gray-50 dark:bg-gray-900/20 border border-gray-200 dark:border-gray-700 rounded-lg">
                        <h5 class="font-semibold text-gray-700 dark:text-gray-300 mb-2">üèóÔ∏è Floor Plan System</h5>
                        <ul class="list-disc list-inside space-y-1 text-sm text-gray-600 dark:text-gray-400">
                            <li><strong>Image Upload:</strong> PNG/JPG support via Admin menu</li>
                            <li><strong>Positioning:</strong> Drag floor plan and TVs (Admin mode)</li>
                            <li><strong>Size Controls:</strong> Precise dimensions with aspect ratio lock</li>
                            <li><strong>Inversion:</strong> Toggle for visibility enhancement</li>
                            <li><strong>Text Labels:</strong> 5 sizes, 6 colors, drag positioning</li>
                        </ul>
                    </div>

                    <!-- Color Management -->
                    <div class="mb-4 p-4 bg-gray-50 dark:bg-gray-900/20 border border-gray-200 dark:border-gray-700 rounded-lg">
                        <h5 class="font-semibold text-gray-700 dark:text-gray-300 mb-2">üé® Color Management</h5>
                        <ul class="list-disc list-inside space-y-1 text-sm text-gray-600 dark:text-gray-400">
                            <li><strong>10 Colors:</strong> Red, Orange, Yellow, Green, Blue, Indigo, Purple, Pink, Teal, Lime</li>
                            <li><strong>Assignment:</strong> Toggle Colors mode ‚Üí click channel cards</li>
                            <li><strong>Effects:</strong> Channel cards + all TVs showing that channel</li>
                            <li><strong>Unique:</strong> One color per channel enforcement</li>
                        </ul>
                    </div>

                    <!-- Admin Controls -->
                    <div class="mb-4 p-4 bg-gray-50 dark:bg-gray-900/20 border border-gray-200 dark:border-gray-700 rounded-lg">
                        <h5 class="font-semibold text-gray-700 dark:text-gray-300 mb-2">üë§ Admin Controls</h5>
                        <ul class="list-disc list-inside space-y-1 text-sm text-gray-600 dark:text-gray-400">
                            <li><strong>Channel Management:</strong> Hide/show individual channels</li>
                            <li><strong>Bulk Operations:</strong> Hide all SD channels</li>
                            <li><strong>TV Layout:</strong> Drag positioning, grid reset</li>
                            <li><strong>Prefix Manager:</strong> Custom program title cleaning</li>
                        </ul>
                    </div>
                </div>

                <!-- Technical Specs -->
                <div class="mb-6">
                    <h4 class="text-lg font-semibold text-gray-900 dark:text-gray-100 mb-4">üîß Technical Specifications</h4>
                    
                    <div class="grid grid-cols-1 md:grid-cols-2 gap-4">
                        <!-- Hardware -->
                        <div class="p-4 bg-gray-50 dark:bg-gray-900/20 border border-gray-200 dark:border-gray-700 rounded-lg">
                            <h5 class="font-semibold text-gray-700 dark:text-gray-300 mb-2">üñ•Ô∏è Hardware</h5>
                            <ul class="list-disc list-inside space-y-1 text-sm text-gray-600 dark:text-gray-400">
                                <li><strong>TVs:</strong> 32 default (expandable to 100)</li>
                                <li><strong>Channels:</strong> ~300 HD/SD channels</li>
                                <li><strong>STB-6500:</strong> IP range 192.168.3.101-132</li>
                                <li><strong>Network:</strong> 192.168.3.x subnet standard</li>
                            </ul>
                        </div>

                        <!-- Integration -->
                        <div class="p-4 bg-gray-50 dark:bg-gray-900/20 border border-gray-200 dark:border-gray-700 rounded-lg">
                            <h5 class="font-semibold text-gray-700 dark:text-gray-300 mb-2">üîó Integration</h5>
                            <ul class="list-disc list-inside space-y-1 text-sm text-gray-600 dark:text-gray-400">
                                <li><strong>COM51:</strong> Headend API integration</li>
                                <li><strong>Commands:</strong> Automatic STB command generation</li>
                                <li><strong>Debug:</strong> API calls and IP address display</li>
                                <li><strong>Support:</strong> (818) 729-8554</li>
                            </ul>
                        </div>
                    </div>
                </div>

                <!-- State Management -->
                <div class="mb-6">
                    <h4 class="text-lg font-semibold text-gray-900 dark:text-gray-100 mb-4">üíæ State Management</h4>
                    
                    <div class="p-4 bg-gray-50 dark:bg-gray-900/20 border border-gray-200 dark:border-gray-700 rounded-lg">
                        <h5 class="font-semibold text-gray-700 dark:text-gray-300 mb-2">Auto-Save System</h5>
                        <ul class="list-disc list-inside space-y-1 text-sm text-gray-600 dark:text-gray-400">
                            <li><strong>Frequency:</strong> 30-second automatic saves</li>
                            <li><strong>Storage:</strong> localStorage + memory fallback</li>
                            <li><strong>Persistence:</strong> TV assignments, positions, colors, settings</li>
                            <li><strong>Export:</strong> Configuration file generation</li>
                        </ul>
                    </div>
                </div>

                <!-- Visual Indicators -->
                <div>
                    <h4 class="text-lg font-semibold text-gray-900 dark:text-gray-100 mb-4">üé® Visual Guide</h4>
                    <div class="grid grid-cols-1 md:grid-cols-4 gap-4">
                        <div class="p-3 bg-purple-50 dark:bg-purple-900/20 border-2 border-purple-300 dark:border-purple-700 rounded-lg text-center">
                            <div class="w-8 h-8 bg-purple-500 rounded mx-auto mb-2 flex items-center justify-center">
                                <span class="text-white text-xs font-bold">TV</span>
                            </div>
                            <h6 class="font-semibold text-purple-700 dark:text-purple-300 text-sm">Blue Highlight</h6>
                            <p class="text-xs text-purple-600 dark:text-purple-400">Channel selected</p>
                        </div>
                        
                        <div class="p-3 bg-orange-50 dark:bg-orange-900/20 border-2 border-orange-300 dark:border-orange-700 rounded-lg text-center">
                            <div class="w-8 h-8 bg-orange-500 rounded mx-auto mb-2 flex items-center justify-center">
                                <span class="text-white text-xs font-bold">TV</span>
                            </div>
                            <h6 class="font-semibold text-orange-700 dark:text-orange-300 text-sm">Orange Highlight</h6>
                            <p class="text-xs text-orange-600 dark:text-orange-400">Copy mode active</p>
                        </div>
                        
                        <div class="p-3 bg-gray-50 dark:bg-gray-900/20 border-2 border-gray-400 dark:border-gray-600 rounded-lg text-center">
                            <div class="w-8 h-8 bg-gray-600 rounded mx-auto mb-2 flex items-center justify-center">
                                <span class="text-white text-xs font-bold">TV</span>
                            </div>
                            <h6 class="font-semibold text-gray-700 dark:text-gray-300 text-sm">Dark Background</h6>
                            <p class="text-xs text-gray-600 dark:text-gray-400">Channel assigned</p>
                        </div>

                        <div class="p-3 bg-green-50 dark:bg-green-900/20 border-2 border-green-300 dark:border-green-700 rounded-lg text-center">
                            <div class="w-8 h-8 bg-green-500 rounded mx-auto mb-2 flex items-center justify-center">
                                <span class="text-white text-xs font-bold">TV</span>
                            </div>
                            <h6 class="font-semibold text-green-700 dark:text-green-300 text-sm">Color Borders</h6>
                            <p class="text-xs text-green-600 dark:text-green-400">Custom colors</p>
                        </div>
                    </div>
                </div>
            </div>
            
            <!-- Footer -->
            <div class="flex justify-end p-6 border-t border-gray-200 dark:border-gray-700">
                <button onclick="closeHelp()" class="px-6 py-2 bg-primary text-white rounded-lg hover:bg-primary/90 transition-colors text-sm font-medium">
                    Got it! üëç
                </button>
            </div>
        </div>
    </div>

    <script>
        // Real channel data from COM51 system (reduced to ~300 for demo)
        const channelData = [
            [2, 65535, 'KCBS', 186803, 0], [2, 65535, 'KCBS', 2734941, 1],
            [4, 65535, 'KNBC', 186804, 0], [4, 65535, 'KNBC', 2734942, 1],
            [5, 65535, 'KTLA', 409815, 0], [5, 65535, 'KTLA', 3223448, 1],
            [7, 65535, 'KABC', 186805, 0], [7, 65535, 'KABC', 2734943, 1],
            [9, 65535, 'KCAL', 186806, 0], [9, 65535, 'KCAL', 3910458, 1],
            [11, 65535, 'KTTV', 512262, 0], [11, 65535, 'KTTV', 2734944, 1],
            [200, 65535, 'SPEED', 5940, 0], [200, 65535, 'SPEEDHD', 3900945, 1],
            [202, 65535, 'CNN', 5941, 0], [202, 65535, 'CNNHD', 3900947, 1],
            [204, 65535, 'HLN', 5943, 0], [204, 65535, 'HLNHD', 9867494, 1],
            [205, 65535, 'FOOD', 5944, 0], [205, 65535, 'FOODHD', 3900950, 1],
            [206, 65535, 'ESPN', 5945, 0], [206, 65535, 'ESPNHD', 2220255, 1],
            [207, 65535, 'ESN', 5946, 0], [207, 65535, 'ESNHD', 3900933, 1],
            [208, 65535, 'ESPNU', 4878136, 0], [208, 65535, 'ESPNUHD', 3101555, 1],
            [209, 65535, 'ESPN2', 415961, 0], [209, 65535, 'ESPN2HD', 2220256, 1],
            [210, 65535, 'SYFY', 5948, 0], [210, 65535, 'SYFYHD', 3900954, 1],
            [212, 65535, 'NFL', 186658, 0], [212, 65535, 'NFLHD', 3900923, 1],
            [213, 65535, 'MLBN', 4304277, 0], [213, 65535, 'MLBNHD', 4304278, 1],
            [215, 65535, 'NHLN', 4220042, 0], [215, 65535, 'NHLHD', 3900928, 1],
            [216, 65535, 'NBA', 186687, 0], [216, 65535, 'NBAHD', 3900918, 1],
            [217, 65535, 'TNNS', 4084507, 0], [217, 65535, 'TNNSHD', 3900938, 1],
            [218, 65535, 'Golf', 6056, 0], [218, 65535, 'GolfHD', 5033574, 1],
            [219, 65535, 'FS1', 6058, 0], [219, 65535, 'FS1HD', 3900940, 1],
            [220, 65535, 'FS2', 4716374, 0], [220, 65535, 'FS2HD', 4716375, 1],
            [221, 65535, 'CBS SN', 4716363, 0], [221, 65535, 'CBSSNHD', 4716374, 1],
            [240, 65535, 'DISC', 5951, 0], [240, 65535, 'DISCHD', 3900968, 1],
            [242, 65535, 'USA', 5953, 0], [242, 65535, 'USAHD', 3900971, 1],
            [244, 65535, 'HIST', 5954, 0], [244, 65535, 'HISTHD', 3900970, 1],
            [245, 65535, 'TNT', 5955, 0], [245, 65535, 'TNTHD', 2220257, 1],
            [247, 65535, 'TBS', 5956, 0], [247, 65535, 'TBSHD', 3900952, 1],
            [248, 65535, 'FX', 186662, 0], [248, 65535, 'FXHD', 3900906, 1],
            [249, 65535, 'A&E', 5958, 0], [249, 65535, 'A&EHD', 3900958, 1],
            [355, 65535, 'CNBC', 5994, 0], [355, 65535, 'CNBCHD', 3900975, 1],
            [356, 65535, 'MSNBC', 5995, 0], [356, 65535, 'MSNBC', 5601803, 1],
            [360, 65535, 'FNC', 5997, 0], [360, 65535, 'FNCHD', 4935060, 1]
        ];

        // Simulated program data with team matchups
        const programData = {
            // Sports
            2220255: { current: "Lakers vs Warriors", next: "SportsCenter", time: "10:00 PM" },
            3900923: { current: "RedZone", next: "Cowboys vs Giants", time: "7:00 PM" },
            2220256: { current: "Duke vs Carolina", next: "GameDay", time: "9:00 PM" },
            3900928: { current: "Rangers vs Kings", next: "NHL Tonight", time: "10:00 PM" },
            3900918: { current: "Knicks vs Nets", next: "NBA GameTime", time: "11:00 PM" },
            3900940: { current: "Chiefs vs Bills", next: "NFL Live", time: "8:00 PM" },
            3900945: { current: "F1 Highlights", next: "NASCAR", time: "7:00 PM" },
            2220257: { current: "Celtics vs Heat", next: "Inside the NBA", time: "10:30 PM" },
            3900933: { current: "Sportscenter", next: "Baseball Tonight", time: "11:00 PM" },
            3101555: { current: "College Gameday", next: "Football", time: "12:00 PM" },
            4304278: { current: "Yankees vs Red Sox", next: "Quick Pitch", time: "10:00 PM" },
            3900938: { current: "US Open Tennis", next: "Tennis Channel Live", time: "6:00 PM" },
            5033574: { current: "PGA Championship", next: "Golf Central", time: "7:00 PM" },
            4716375: { current: "Premier League", next: "MLS Soccer", time: "4:00 PM" },
            4716374: { current: "NCAA Basketball", next: "March Madness", time: "9:00 PM" },
            
            // News  
            3900947: { current: "Breaking News", next: "Anderson Cooper", time: "8:00 PM" },
            5941: { current: "Election Coverage", next: "The Situation Room", time: "6:00 PM" },
            9867494: { current: "Morning Express", next: "CNN Live", time: "9:00 AM" },
            3900975: { current: "Squawk Box", next: "Power Lunch", time: "12:00 PM" },
            5601803: { current: "Morning Joe", next: "Andrea Mitchell", time: "12:00 PM" },
            4935060: { current: "Tucker Carlson", next: "Hannity", time: "9:00 PM" },
            
            // Entertainment
            3900971: { current: "Law & Order: SVU", next: "WWE Raw", time: "8:00 PM" },
            3900950: { current: "Chopped", next: "Beat Bobby Flay", time: "9:00 PM" },
            3900954: { current: "The Expanse", next: "Battlestar Galactica", time: "10:00 PM" },
            3900968: { current: "Deadliest Catch", next: "Gold Rush", time: "9:00 PM" },
            3900970: { current: "Ancient Aliens", next: "The Universe", time: "8:00 PM" },
            3900952: { current: "The Big Bang Theory", next: "Young Sheldon", time: "8:00 PM" },
            3900906: { current: "American Horror Story", next: "Atlanta", time: "10:00 PM" },
            3900958: { current: "The First 48", next: "Live PD", time: "9:00 PM" },
            
            // Local  
            186803: { current: "Local News", next: "Evening News", time: "6:00 PM" },
            2734941: { current: "CBS Evening News", next: "60 Minutes", time: "7:00 PM" },
            186804: { current: "NBC Nightly News", next: "Dateline", time: "8:00 PM" },
            2734942: { current: "Today Show", next: "NBC News", time: "11:00 AM" },
            409815: { current: "KTLA Morning News", next: "Judge Judy", time: "11:00 AM" },
            3223448: { current: "KTLA 5 News", next: "Seinfeld", time: "7:00 PM" },
            186805: { current: "ABC World News", next: "Jeopardy!", time: "7:00 PM" },
            2734943: { current: "Good Morning America", next: "The View", time: "11:00 AM" },
            186806: { current: "KCAL 9 News", next: "Judge Judy", time: "4:00 PM" },
            3910458: { current: "Local Programming", next: "Syndicated Shows", time: "3:00 PM" },
            512262: { current: "FOX 11 News", next: "The Simpsons", time: "7:00 PM" },
            2734944: { current: "FOX Morning Show", next: "Maury", time: "10:00 AM" }
        };

        // App state
        let selectedChannel = null;
        let selectedTVForCopy = null;
        let currentFilter = 'hd';
        let channels = [];
        let tvs = [];
        let tunerAssignments = {};
        let debugMode = false;
        let channelSelectionTimeout = null;
        let prefixManagerOpen = false;
        let adminMode = false;
        let hiddenChannels = new Set();
        let selectedTVsForMultiCopy = new Set();
        let adminMenuOpen = false;
        
        // Color Management
        let colorMode = false;
        let channelColors = {}; // channelObjectId -> colorName
        let selectedChannelForColoring = null;
        let selectedColorForAssignment = null;
        
        // Available colors for assignment
        const availableColors = [
            { name: 'red', value: '#EF4444', bgTint: '#FEF2F2', borderTint: '#EF4444' },
            { name: 'orange', value: '#F97316', bgTint: '#FFF7ED', borderTint: '#F97316' },
            { name: 'yellow', value: '#EAB308', bgTint: '#FEFCE8', borderTint: '#EAB308' },
            { name: 'green', value: '#22C55E', bgTint: '#F0FDF4', borderTint: '#22C55E' },
            { name: 'blue', value: '#3B82F6', bgTint: '#EFF6FF', borderTint: '#3B82F6' },
            { name: 'indigo', value: '#6366F1', bgTint: '#EEF2FF', borderTint: '#6366F1' },
            { name: 'purple', value: '#A855F7', bgTint: '#FAF5FF', borderTint: '#A855F7' },
            { name: 'pink', value: '#EC4899', bgTint: '#FDF2F8', borderTint: '#EC4899' },
            { name: 'teal', value: '#14B8A6', bgTint: '#F0FDFA', borderTint: '#14B8A6' },
            { name: 'lime', value: '#65A30D', bgTint: '#F7FEE7', borderTint: '#65A30D' }
        ];
        
        // Program prefixes to strip from TV displays
        let programPrefixes = [
            "NBA Basketball:",
            "Basketball:",
            "NFL Football:",
            "Football:",
            "MLB Baseball:",
            "Baseball:",
            "College Football:",
            "College Basketball:",
            "Soccer:",
            "Hockey:",
            "NFL RedZone",
            "SportsCenter"
        ];

        // Initialize the app
        function processChannelData() {
            channels = channelData
                .map(ch => ({
                    major: ch[0],
                    minor: ch[1],
                    name: ch[2],
                    objectId: ch[3],
                    isHD: ch[4] === 1,
                    displayName: ch[2] + (ch[4] === 1 && !ch[2].includes('HD') ? ' HD' : ''),
                    channelNum: ch[1] === 65535 ? ch[0].toString() : `${ch[0]}.${ch[1]}`,
                    categories: getCategoriesForChannel(ch[2]),
                    program: programData[ch[3]] || { current: "Programming", next: "Next Show", time: "TBA" }
                }))
                .sort((a, b) => a.major - b.major);
        }

        function getCategoriesForChannel(name) {
            const categories = [];
            const sportsChannels = ['ESPN', 'ESN', 'ESPNU', 'ESPN2', 'NFL', 'MLBN', 'NHLN', 'NBA', 'TNNS', 'Golf', 'FS1', 'FS2', 'CBS SN', 'SPEED'];
            const newsChannels = ['CNN', 'HLN', 'CNBC', 'MSNBC', 'FNC'];
            
            if (sportsChannels.some(sport => name.includes(sport))) {
                categories.push('sports');
            }
            if (newsChannels.some(news => name.includes(news))) {
                categories.push('news');
            }
            return categories;
        }

        function createTVGrid(tvCount = 24) {
            const grid = document.getElementById('tv-grid');
            tvs = [];
            
            // Clear grid
            grid.innerHTML = '';
            
            // Create TVs positioned in a grid layout within the floor plan area
            for (let i = 1; i <= tvCount; i++) {
                // Position TVs in a grid layout initially
                const cols = 8; // 8 columns
                const row = Math.floor((i - 1) / cols);
                const col = (i - 1) % cols;
                const startX = 50;
                const startY = 50;
                const spacingX = 140;
                const spacingY = 110;

                const tv = {
                    id: i,
                    name: `TV ${i}`,
                    assignedChannel: null,
                    assignedTuner: null,
                    ipAddress: `192.168.3.${100 + i}`,
                    x: startX + (col * spacingX),
                    y: startY + (row * spacingY)
                };
                tvs.push(tv);
                
                const tvElement = document.createElement('div');
                tvElement.className = 'tv-box bg-gray-100 dark:bg-gray-700 rounded-lg p-2 text-center cursor-move hover:bg-gray-200 dark:hover:bg-gray-600 border-2 border-transparent w-28 h-24 flex flex-col absolute user-select-none pointer-events-auto';
                tvElement.id = `tv-${i}`;
                
                // Set initial position
                tvElement.style.left = tv.x + 'px';
                tvElement.style.top = tv.y + 'px';
                
                tvElement.onclick = (event) => {
                    event.stopPropagation();
                    // Only handle click if user didn't drag significantly
                    if (!hasDraggedSignificantly) {
                        handleTVClick(i);
                    }
                };
                
                // Create TV content container
                const tvContent = document.createElement('div');
                tvContent.className = 'flex flex-col h-full justify-between';
                
                // TV number and channel side by side at top
                tvContent.innerHTML = `
                    <div class="flex justify-between text-xs font-bold text-gray-600 dark:text-gray-400">
                        <span>TV ${i}</span>
                        <span id="tv-${i}-channel-num" class="hidden">206</span>
                    </div>
                    <div id="tv-${i}-channel" class="text-xs text-gray-500 dark:text-gray-400 mt-1 flex-1">Available</div>
                `;
                
                tvElement.appendChild(tvContent);
                
                // Add dragging functionality
                let isDragging = false;
                let dragStartX, dragStartY, dragStartLeft, dragStartTop;
                let currentTVBeingDragged = null;
                let hasDraggedSignificantly = false;
                
                tvElement.addEventListener('mousedown', (e) => {
                    if (e.button === 0 && adminMode) { // Left mouse button AND admin mode
                        isDragging = true;
                        currentTVBeingDragged = i;
                        dragStartX = e.clientX;
                        dragStartY = e.clientY;
                        dragStartLeft = parseInt(tvElement.style.left) || 0;
                        dragStartTop = parseInt(tvElement.style.top) || 0;
                        tvElement.style.zIndex = '1000';
                        tvElement.style.opacity = '0.8';
                        tvElement.style.cursor = 'grabbing';
                        e.preventDefault();
                        e.stopPropagation();
                    }
                });
                
                // Global mouse move handler
                const handleMouseMove = (e) => {
                    if (isDragging && currentTVBeingDragged === i) {
                        const deltaX = e.clientX - dragStartX;
                        const deltaY = e.clientY - dragStartY;
                        
                        // Check if user has dragged significantly (more than 5 pixels)
                        if (Math.abs(deltaX) > 5 || Math.abs(deltaY) > 5) {
                            hasDraggedSignificantly = true;
                        }
                        
                        const newLeft = Math.max(0, Math.min(dragStartLeft + deltaX, grid.clientWidth - 112));
                        const newTop = Math.max(0, Math.min(dragStartTop + deltaY, grid.clientHeight - 96));
                        
                        tvElement.style.left = newLeft + 'px';
                        tvElement.style.top = newTop + 'px';
                        
                        // Update TV position data
                        tv.x = newLeft;
                        tv.y = newTop;
                        e.preventDefault();
                    }
                };
                
                // Global mouse up handler
                const handleMouseUp = (e) => {
                    if (isDragging && currentTVBeingDragged === i) {
                        isDragging = false;
                        currentTVBeingDragged = null;
                        tvElement.style.zIndex = '10';
                        tvElement.style.opacity = '1';
                        tvElement.style.cursor = 'move';
                        
                        // Reset drag flag after a small delay to prevent click handler
                        setTimeout(() => {
                            hasDraggedSignificantly = false;
                        }, 50);
                        
                        e.preventDefault();
                    }
                };
                
                // Attach global listeners
                document.addEventListener('mousemove', handleMouseMove);
                document.addEventListener('mouseup', handleMouseUp);
                
                // Touch support for iPad
                tvElement.addEventListener('touchstart', (e) => {
                    if (adminMode) { // Only allow touch dragging in admin mode
                        const touch = e.touches[0];
                        isDragging = true;
                        currentTVBeingDragged = i;
                        dragStartX = touch.clientX;
                        dragStartY = touch.clientY;
                        dragStartLeft = parseInt(tvElement.style.left) || 0;
                        dragStartTop = parseInt(tvElement.style.top) || 0;
                        tvElement.style.zIndex = '1000';
                        tvElement.style.opacity = '0.8';
                        e.preventDefault();
                    }
                });
                
                // Global touch move handler
                const handleTouchMove = (e) => {
                    if (isDragging && currentTVBeingDragged === i) {
                        const touch = e.touches[0];
                        const deltaX = touch.clientX - dragStartX;
                        const deltaY = touch.clientY - dragStartY;
                        
                        // Check if user has dragged significantly (more than 5 pixels)
                        if (Math.abs(deltaX) > 5 || Math.abs(deltaY) > 5) {
                            hasDraggedSignificantly = true;
                        }
                        
                        const newLeft = Math.max(0, Math.min(dragStartLeft + deltaX, grid.clientWidth - 112));
                        const newTop = Math.max(0, Math.min(dragStartTop + deltaY, grid.clientHeight - 96));
                        
                        tvElement.style.left = newLeft + 'px';
                        tvElement.style.top = newTop + 'px';
                        
                        // Update TV position data
                        tv.x = newLeft;
                        tv.y = newTop;
                        e.preventDefault();
                    }
                };
                
                // Global touch up handler
                const handleTouchEnd = (e) => {
                    if (isDragging && currentTVBeingDragged === i) {
                        isDragging = false;
                        currentTVBeingDragged = null;
                        tvElement.style.zIndex = '10';
                        tvElement.style.opacity = '1';
                        
                        // Reset drag flag after a small delay to prevent click handler
                        setTimeout(() => {
                            hasDraggedSignificantly = false;
                        }, 50);
                        
                        e.preventDefault();
                    }
                };
                
                // Attach global touch listeners
                document.addEventListener('touchmove', handleTouchMove, { passive: false });
                document.addEventListener('touchend', handleTouchEnd);
                
                grid.appendChild(tvElement);
            }
        }

        function resetTVPositions() {
            const cols = 8;
            const startX = 50;
            const startY = 50;
            const spacingX = 140;
            const spacingY = 110;
            
            tvs.forEach((tv, index) => {
                const row = Math.floor(index / cols);
                const col = index % cols;
                
                tv.x = startX + (col * spacingX);
                tv.y = startY + (row * spacingY);
                
                const tvElement = document.getElementById(`tv-${tv.id}`);
                if (tvElement) {
                    tvElement.style.left = tv.x + 'px';
                    tvElement.style.top = tv.y + 'px';
                }
            });
            
            showMessage('TV Positions Reset', 'All TVs have been arranged in a grid layout.');
        }

        // Admin menu functions
        function toggleAdminMenu() {
            adminMenuOpen = !adminMenuOpen;
            const menu = document.getElementById('admin-menu');
            
            if (adminMenuOpen) {
                menu.classList.remove('hidden');
                // Update admin mode text
                document.getElementById('admin-mode-text').textContent = adminMode ? 'Disable Admin Mode' : 'Enable Admin Mode';
                // Update invert button text
                const invertBtn = document.getElementById('admin-invert-btn');
                invertBtn.textContent = floorPlanInverted ? '‚ö™ Normal Image' : 'üîÑ Invert Image';
            } else {
                menu.classList.add('hidden');
            }
        }

        function closeAdminMenu() {
            adminMenuOpen = false;
            document.getElementById('admin-menu').classList.add('hidden');
        }

        // Close admin menu when clicking outside
        document.addEventListener('click', (e) => {
            const adminToggle = document.getElementById('admin-toggle');
            const adminMenu = document.getElementById('admin-menu');
            
            if (adminMenuOpen && !adminToggle.contains(e.target) && !adminMenu.contains(e.target)) {
                closeAdminMenu();
            }
        });

        function renderChannels() {
            const grid = document.getElementById('channel-grid');
            const searchTerm = document.getElementById('channel-search').value.toLowerCase();
            
            let filteredChannels = channels.filter(channel => {
                const matchesSearch = !searchTerm || 
                    channel.name.toLowerCase().includes(searchTerm) ||
                    channel.channelNum.includes(searchTerm) ||
                    channel.displayName.toLowerCase().includes(searchTerm) ||
                    channel.program.current.toLowerCase().includes(searchTerm) ||
                    channel.program.next.toLowerCase().includes(searchTerm);
                
                let matchesFilter = true;
                if (currentFilter === 'sports') {
                    matchesFilter = channel.categories.includes('sports') && channel.isHD;
                } else if (currentFilter === 'news') {
                    matchesFilter = channel.categories.includes('news') && channel.isHD;
                } else if (currentFilter === 'football') {
                    matchesFilter = channel.categories.includes('sports') && isFootballContent(channel.program.current) && channel.isHD;
                } else if (currentFilter === 'basketball') {
                    matchesFilter = channel.categories.includes('sports') && isBasketballContent(channel.program.current) && channel.isHD;
                } else if (currentFilter === 'baseball') {
                    matchesFilter = channel.categories.includes('sports') && isBaseballContent(channel.program.current) && channel.isHD;
                } else if (currentFilter === 'soccer') {
                    matchesFilter = channel.categories.includes('sports') && isSoccerContent(channel.program.current) && channel.isHD;
                } else if (currentFilter === 'hockey') {
                    matchesFilter = channel.categories.includes('sports') && isHockeyContent(channel.program.current) && channel.isHD;
                } else if (currentFilter === 'mma') {
                    matchesFilter = channel.categories.includes('sports') && isMMAContent(channel.program.current) && channel.isHD;
                } else if (currentFilter === 'hd') {
                    matchesFilter = channel.isHD;
                } else if (currentFilter === 'sd') {
                    matchesFilter = true; // Show all channels (HD + SD) when "Show SD" is clicked
                } else if (currentFilter === 'all') {
                    // "All" means all HD channels by default, unless admin mode is on
                    matchesFilter = adminMode ? true : channel.isHD;
                } else {
                    // Default case - show HD only
                    matchesFilter = channel.isHD;
                }
                
                // In admin mode, show all channels. In normal mode, hide hidden channels
                const isVisible = adminMode || !hiddenChannels.has(channel.objectId);
                
                return matchesSearch && matchesFilter && isVisible;
            });

            grid.innerHTML = '';
            
            if (filteredChannels.length === 0) {
                document.getElementById('no-results').classList.remove('hidden');
                return;
            } else {
                document.getElementById('no-results').classList.add('hidden');
            }

            filteredChannels.forEach(channel => {
                const channelElement = document.createElement('div');
                channelElement.className = `channel-row p-3 cursor-pointer hover:bg-gray-50 dark:hover:bg-gray-700 transition-colors ${selectedChannel?.objectId === channel.objectId ? 'channel-selected' : ''}`;
                channelElement.onclick = (event) => {
                    // Check if color mode is active first
                    if (colorMode && handleChannelColorClick(channel)) {
                        event.stopPropagation();
                        return;
                    }
                    selectChannel(channel);
                };
                
                // Add data attribute for color styling
                channelElement.setAttribute('data-channel-id', channel.objectId);
                
                // Get assigned TVs for this channel
                const assignedTVs = tvs.filter(tv => tv.assignedChannel?.objectId === channel.objectId);
                const tvCount = assignedTVs.length;
                const tvNumbers = assignedTVs.map(tv => tv.id).join(', ');
                
                const sdBadge = !channel.isHD ? '<span class="ml-2 px-2 py-1 text-xs bg-yellow-100 text-yellow-800 dark:bg-yellow-900 dark:text-yellow-200 rounded-full">SD</span>' : '';
                
                // Right-justified category tags
                const categoryTags = [];
                if (channel.categories.includes('sports')) {
                    categoryTags.push('<span class="px-2 py-1 text-xs bg-green-100 text-green-800 dark:bg-green-900 dark:text-green-200 rounded-full">SPORTS</span>');
                }
                if (channel.categories.includes('news')) {
                    categoryTags.push('<span class="px-2 py-1 text-xs bg-red-100 text-red-800 dark:bg-red-900 dark:text-red-200 rounded-full">NEWS</span>');
                }
                
                // Show TV assignment in white text (no blob/badge)
                const assignmentInfo = tvCount > 0 ? `<div class="text-xs text-white dark:text-white mt-2">Assigned to TVs ${tvNumbers}</div>` : '';
                const debugInfo = debugMode ? `<div class="text-xs text-gray-500 dark:text-gray-400 mt-1">ID: ${channel.objectId}</div>` : '';
                
                // Show hide/show buttons in admin mode
                const isHidden = hiddenChannels.has(channel.objectId);
                const adminButton = adminMode ? 
                    (isHidden ? 
                        `<button onclick="showChannel(${channel.objectId}); event.stopPropagation();" class="px-2 py-1 text-xs bg-green-100 text-green-700 dark:bg-green-900 dark:text-green-300 rounded hover:bg-green-200 dark:hover:bg-green-800 transition-colors">üëÅÔ∏è Show</button>` :
                        `<button onclick="hideChannel(${channel.objectId}); event.stopPropagation();" class="px-2 py-1 text-xs bg-red-100 text-red-700 dark:bg-red-900 dark:text-red-300 rounded hover:bg-red-200 dark:hover:bg-red-800 transition-colors">üö´ Hide</button>`
                    ) : '';
                
                channelElement.innerHTML = `
                    <div class="flex items-center justify-between mb-2">
                        <div class="flex items-center space-x-3">
                            <span class="text-base font-bold text-gray-900 dark:text-gray-100 w-12">${channel.channelNum}</span>
                            <span class="text-base font-semibold text-gray-900 dark:text-gray-100 channel-name">${channel.displayName}</span>
                            ${sdBadge}
                            ${isHidden ? '<span class="ml-2 px-2 py-1 text-xs bg-gray-100 text-gray-600 dark:bg-gray-700 dark:text-gray-400 rounded-full">HIDDEN</span>' : ''}
                        </div>
                        <div class="flex items-center space-x-2">
                            ${categoryTags.join(' ')}
                            ${adminButton}
                        </div>
                    </div>
                    <div class="text-sm text-gray-700 dark:text-gray-300">
                        <div class="flex items-center space-x-2">
                            <span class="text-xs text-gray-500">NOW:</span>
                            <span class="text-base font-bold text-white dark:text-white">${channel.program.current}</span>
                        </div>
                        <div class="flex items-center space-x-2 mt-1">
                            <span class="text-xs text-gray-500">NEXT:</span>
                            <span>${channel.program.next}</span>
                            <span class="text-xs text-gray-400">(${channel.program.time})</span>
                        </div>
                    </div>
                    ${assignmentInfo}
                    ${debugInfo}
                `;
                
                grid.appendChild(channelElement);
            });
            
            // Apply colors after rendering
            setTimeout(() => applyChannelColors(), 0);
        }

        function selectChannel(channel) {
            selectedChannel = channel;
            selectedTVForCopy = null; // Clear TV selection when selecting channel
            
            // Clear any existing timeout
            if (channelSelectionTimeout) {
                clearTimeout(channelSelectionTimeout);
            }
            
            // Update header UI
            updateHeaderSelection();
            
            // Clear TV selection highlights
            clearAllHighlights();
            
            // Highlight TVs assigned to this channel
            highlightTVsWithChannel(channel.objectId);
            
            // Re-render to show selection
            renderChannels();
            
            // Set timeout to clear selection after 5 seconds
            channelSelectionTimeout = setTimeout(() => {
                clearChannelSelection();
            }, 5000);
        }
        
        function updateHeaderSelection() {
            const headerChannelElement = document.getElementById('header-selected-channel');
            const headerTVElement = document.getElementById('header-selected-tv');
            const headerNoSelectionElement = document.getElementById('header-no-selection');
            
            if (selectedChannel && selectedChannel.displayName && selectedChannel.channelNum) {
                headerChannelElement.textContent = `${selectedChannel.channelNum} ${selectedChannel.displayName}`;
                headerChannelElement.classList.remove('hidden');
                headerTVElement.classList.add('hidden');
                headerNoSelectionElement.classList.add('hidden');
                
                // Apply channel color if assigned
                const channelColor = getChannelColor(selectedChannel.objectId);
                if (channelColor) {
                    headerChannelElement.style.color = channelColor.borderTint;
                } else {
                    // Set to white when no color assigned
                    headerChannelElement.style.color = 'white';
                }
            } else if (selectedTVForCopy && selectedTVForCopy.name && selectedTVForCopy.assignedChannel && selectedTVForCopy.assignedChannel.channelNum && selectedTVForCopy.assignedChannel.name) {
                headerTVElement.textContent = `Copy from ${selectedTVForCopy.name} (${selectedTVForCopy.assignedChannel.channelNum} ${selectedTVForCopy.assignedChannel.name})`;
                headerTVElement.classList.remove('hidden');
                headerChannelElement.classList.add('hidden');
                headerNoSelectionElement.classList.add('hidden');
                
                // Apply channel color for TV copy selection too
                const channelColor = getChannelColor(selectedTVForCopy.assignedChannel.objectId);
                if (channelColor) {
                    headerTVElement.style.color = channelColor.borderTint;
                } else {
                    // Reset to default orange color
                    headerTVElement.style.color = '';
                }
            } else {
                // Clear any invalid selections
                selectedChannel = null;
                selectedTVForCopy = null;
                
                headerChannelElement.classList.add('hidden');
                headerTVElement.classList.add('hidden');
                headerNoSelectionElement.classList.remove('hidden');
                
                // Reset colors when nothing is selected
                headerChannelElement.style.color = '';
                headerTVElement.style.color = '';
            }
        }
        
        function clearChannelSelection() {
            selectedChannel = null;
            selectedTVForCopy = null;
            updateHeaderSelection();
            clearAllHighlights();
            renderChannels();
            
            if (channelSelectionTimeout) {
                clearTimeout(channelSelectionTimeout);
                channelSelectionTimeout = null;
            }
        }

        function handleTVClick(tvId) {
            const tv = tvs.find(t => t.id === tvId);
            
            if (selectedChannel) {
                // Channel is selected, assign it to this TV
                assignChannelToTV(tvId);
                // Keep selectedChannel active for multiple assignments
                // Clear TV selection if any
                selectedTVForCopy = null;
                clearAllHighlights();
                // Re-highlight TVs with this channel
                highlightTVsWithChannel(selectedChannel.objectId);
            } else if (selectedTVForCopy) {
                // Copy channel from selected TV to this TV
                copyChannelBetweenTVs(selectedTVForCopy.id, tvId);
                // Keep selectedTVForCopy active for multiple copies
                // Re-highlight the source TV and others with same channel
                clearAllHighlights();
                const sourceElement = document.getElementById(`tv-${selectedTVForCopy.id}`);
                if (sourceElement) {
                    sourceElement.classList.add('tv-selected-for-copy');
                    
                    // Apply channel's color for the selected TV for copy - more prominent
                    const channelColor = getChannelColor(selectedTVForCopy.assignedChannel.objectId);
                    if (channelColor) {
                        sourceElement.style.setProperty('box-shadow', `0 0 35px ${channelColor.borderTint}A0`, 'important');
                        sourceElement.style.setProperty('border', `4px solid ${channelColor.borderTint}`, 'important');
                    } else {
                        // Use default orange if no color assigned - more prominent
                        sourceElement.style.setProperty('box-shadow', '0 0 35px #F59E0BA0', 'important');
                        sourceElement.style.setProperty('border', '4px solid #F59E0B', 'important');
                    }
                    sourceElement.style.transform = 'scale(1.1)';
                }
                
                highlightTVsWithChannel(selectedTVForCopy.assignedChannel.objectId);
            } else if (tv.assignedChannel) {
                // Select this TV for copying
                selectedTVForCopy = tv;
                selectedChannel = null; // Clear channel selection when selecting TV for copy
                
                // Clear any existing timeout
                if (channelSelectionTimeout) {
                    clearTimeout(channelSelectionTimeout);
                }
                
                updateHeaderSelection();
                
                clearAllHighlights();
                
                // Highlight this TV for copying using its channel's color
                const element = document.getElementById(`tv-${tvId}`);
                if (element) {
                    element.classList.add('tv-selected-for-copy');
                    
                    // Apply channel's color if it has one - more prominent
                    const channelColor = getChannelColor(tv.assignedChannel.objectId);
                    if (channelColor) {
                        element.style.setProperty('box-shadow', `0 0 35px ${channelColor.borderTint}A0`, 'important');
                        element.style.setProperty('border', `4px solid ${channelColor.borderTint}`, 'important');
                    } else {
                        // Use default orange if no color assigned - more prominent
                        element.style.setProperty('box-shadow', '0 0 35px #F59E0BA0', 'important');
                        element.style.setProperty('border', '4px solid #F59E0B', 'important');
                    }
                    element.style.transform = 'scale(1.1)';
                }
                
                // Also highlight other TVs with same channel
                highlightTVsWithChannel(tv.assignedChannel.objectId);
                
                // Set timeout to clear TV copy selection after 5 seconds
                channelSelectionTimeout = setTimeout(() => {
                    clearChannelSelection();
                }, 5000);
            } else {
                showMessage('No Channel to Copy', 'This TV has no channel assigned. Select a channel from the guide or choose a TV with a channel to copy from.');
            }
        }

        function copyChannelBetweenTVs(sourceTVId, targetTVId) {
            const sourceTV = tvs.find(t => t.id === sourceTVId);
            const targetTV = tvs.find(t => t.id === targetTVId);
            
            if (!sourceTV.assignedChannel) return;
            
            // Find or assign tuner for the channel
            const tuner = findOrAssignTuner(sourceTV.assignedChannel);
            
            // Assign to target TV
            targetTV.assignedChannel = sourceTV.assignedChannel;
            targetTV.assignedTuner = tuner;
            
            // User made changes - reset active preset state
            detectConfigurationChange();
            
            updateTVDisplay(targetTVId);
            renderChannels(); // Refresh to show updated assignment counts
            
            // Simulate API call
            simulateChannelAssignment(sourceTV.assignedChannel, tuner, targetTVId);
        }

        function highlightTVsWithChannel(channelObjectId) {
            const channelColor = getChannelColor(channelObjectId);
            
            tvs.forEach(tv => {
                if (tv.assignedChannel?.objectId === channelObjectId) {
                    const element = document.getElementById(`tv-${tv.id}`);
                    if (element) {
                        // Use channel's assigned color for highlighting if available - more prominent
                        if (channelColor) {
                            // Don't add the CSS class, use inline styles only for custom colors - more prominent
                            element.style.setProperty('box-shadow', `0 0 35px ${channelColor.borderTint}A0`, 'important');
                            element.style.setProperty('border', `5px solid ${channelColor.borderTint}`, 'important');
                            element.style.transform = 'scale(1.1)';
                            element.setAttribute('data-custom-highlighted', 'true');
                        } else {
                            // Use default purple highlighting for channels without custom colors
                            element.classList.add('tv-highlighted');
                        }
                    }
                }
            });
            // Highlights will persist until manually cleared by timeout or channel change
        }

        function clearAllHighlights() {
            tvs.forEach(tv => {
                const element = document.getElementById(`tv-${tv.id}`);
                if (element) {
                    element.classList.remove('tv-highlighted', 'tv-selected-for-copy');
                    
                    // Remove custom highlight attributes
                    element.removeAttribute('data-custom-highlighted');
                    
                    // Force reset any stuck transforms or styling
                    element.style.transform = '';
                    element.style.boxShadow = '';
                    element.style.border = '';
                    
                    // Reapply proper styling based on current state
                    if (tv.assignedChannel) {
                        element.classList.add('tv-assigned');
                        // Reapply color if channel has one assigned
                        const color = getChannelColor(tv.assignedChannel.objectId);
                        if (color) {
                            element.style.setProperty('border-color', color.borderTint, 'important');
                            element.style.setProperty('border-width', '3px', 'important');
                            element.style.setProperty('border-style', 'solid', 'important');
                        }
                    } else {
                        element.classList.remove('tv-assigned');
                    }
                }
            });
        }

        function assignChannelToTV(tvId) {
            if (!selectedChannel) return;

            const tv = tvs.find(t => t.id === tvId);
            if (!tv) return;

            // Check if clearing assignment
            if (tv.assignedChannel?.objectId === selectedChannel.objectId) {
                clearTVAssignment(tvId);
                return;
            }

            // Simulate tuner assignment
            const tuner = findOrAssignTuner(selectedChannel);
            
            // Update TV assignment
            tv.assignedChannel = selectedChannel;
            tv.assignedTuner = tuner;
            
            // User made changes - reset active preset state
            detectConfigurationChange();
            
            // Update UI
            updateTVDisplay(tvId);
            renderChannels(); // Refresh to show new assignment counts
            
            // Reset the timeout to keep channel selected for more assignments
            if (channelSelectionTimeout) {
                clearTimeout(channelSelectionTimeout);
            }
            channelSelectionTimeout = setTimeout(() => {
                clearChannelSelection();
            }, 5000);
            
            // Simulate API call to COM51
            simulateChannelAssignment(selectedChannel, tuner, tvId);
        }

        function findOrAssignTuner(channel) {
            // Check if channel is already on a tuner
            for (let tunerId in tunerAssignments) {
                if (tunerAssignments[tunerId].objectId === channel.objectId) {
                    return parseInt(tunerId);
                }
            }
            
            // Find next available tuner
            for (let i = 1; i <= 23; i++) {
                if (!tunerAssignments[i]) {
                    tunerAssignments[i] = channel;
                    updateTunerStatus();
                    return i;
                }
            }
            
            showMessage('No Tuners Available', 'All 23 tuners are in use. Please clear some assignments first.');
            return null;
        }

        function clearTVAssignment(tvId) {
            const tv = tvs.find(t => t.id === tvId);
            if (!tv || !tv.assignedChannel) return;
            
            const tunerId = tv.assignedTuner;
            tv.assignedChannel = null;
            tv.assignedTuner = null;
            
            // Check if any other TVs are using this tuner
            const tunerStillInUse = tvs.some(t => t.assignedTuner === tunerId);
            if (!tunerStillInUse && tunerAssignments[tunerId]) {
                delete tunerAssignments[tunerId];
                updateTunerStatus();
            }
            
            // User made changes - reset active preset state
            detectConfigurationChange();
            
            updateTVDisplay(tvId);
            renderChannels(); // Refresh to show updated assignment counts
        }

        // Advanced Preset Button State Management
        function detectConfigurationChange() {
            // User has made manual changes - reset the active preset state
            if (activePreset !== null) {
                activePreset = null;
                updateAllPresetButtonAppearances();
            }
        }

        function updateAllPresetButtonAppearances() {
            for (let i = 1; i <= 3; i++) {
                updatePresetButtonState(i);
            }
        }

        function updatePresetButtonState(presetNum) {
            const button = document.querySelector(`button[onmousedown*="handlePresetMouseDown(${presetNum})"]`);
            if (!button) return;

            const hasContent = presets[presetNum] !== null;
            const isActive = activePreset === presetNum;

            if (isActive) {
                // Teal: Currently active/recalled preset
                button.className = 'px-3 py-1 text-xs bg-teal-100 text-teal-700 dark:bg-teal-900 dark:text-teal-300 rounded hover:bg-teal-200 dark:hover:bg-teal-800 transition-colors font-semibold';
            } else if (hasContent) {
                // Blue: Has stored preset but not currently active
                button.className = 'px-3 py-1 text-xs bg-blue-100 text-blue-700 dark:bg-blue-900 dark:text-blue-300 rounded hover:bg-blue-200 dark:hover:bg-blue-800 transition-colors font-semibold';
            } else {
                // Grey: Empty preset slot
                button.className = 'px-3 py-1 text-xs bg-gray-100 text-gray-600 dark:bg-gray-700 dark:text-gray-400 rounded hover:bg-gray-200 dark:hover:bg-gray-600 transition-colors font-semibold';
            }
        }

        function cleanProgramTitle(title) {
            let cleanTitle = title;
            
            // Remove prefixes from the title
            for (const prefix of programPrefixes) {
                if (cleanTitle.startsWith(prefix)) {
                    cleanTitle = cleanTitle.substring(prefix.length).trim();
                    break;
                }
            }
            
            // Only truncate if extremely long (allow much more text)
            if (cleanTitle.length > 32) {
                cleanTitle = cleanTitle.substring(0, 30) + '..';
            }
            
            return cleanTitle;
        }

        function updateTVDisplay(tvId) {
            const tv = tvs.find(t => t.id === tvId);
            const tvElement = document.getElementById(`tv-${tvId}`);
            const channelDisplay = document.getElementById(`tv-${tvId}-channel`);
            const channelNumSpan = document.getElementById(`tv-${tvId}-channel-num`);
            
            if (tv.assignedChannel) {
                tvElement.classList.add('tv-assigned');
                tvElement.classList.remove('tv-highlighted', 'tv-selected-for-copy');
                
                // Format: Channel#, Call Sign, Current Program (side by side format)
                const channelNumber = tv.assignedChannel.channelNum;
                const callSign = tv.assignedChannel.name.replace('HD', '').trim();
                const programTitle = tv.assignedChannel.program.current;
                const cleanTitle = cleanProgramTitle(programTitle);
                
                // Show channel number next to TV number
                channelNumSpan.textContent = channelNumber;
                channelNumSpan.classList.remove('hidden');
                
                const displayContent = debugMode ? 
                    `<div class="text-xs text-yellow-400 leading-tight mb-1">${tv.ipAddress}</div>
                     <div class="border-t border-gray-500 mb-1"></div>
                     <div class="text-xs font-bold text-white leading-tight">${callSign}</div>
                     <div class="text-xs text-gray-200 leading-tight flex-1 mt-1">${cleanTitle}</div>` :
                    `<div class="border-t border-gray-500 mb-1"></div>
                     <div class="text-xs font-bold text-white leading-tight">${callSign}</div>
                     <div class="text-xs text-gray-200 leading-tight flex-1 mt-1">${cleanTitle}</div>`;
                
                channelDisplay.innerHTML = displayContent;
                channelDisplay.className = 'flex flex-col h-full';
            } else {
                tvElement.classList.remove('tv-assigned', 'tv-highlighted', 'tv-selected-for-copy');
                tvElement.className = 'tv-box bg-gray-100 dark:bg-gray-700 rounded-lg p-2 text-center cursor-move hover:bg-gray-200 dark:hover:bg-gray-600 border-2 border-transparent w-28 h-24 flex flex-col absolute user-select-none pointer-events-auto';
                
                // Hide channel number when no assignment
                channelNumSpan.classList.add('hidden');
                
                channelDisplay.innerHTML = debugMode ? 
                    `<div class="text-xs text-yellow-400 leading-tight mb-1">${tv.ipAddress}</div>
                     <div class="text-xs text-gray-500 dark:text-gray-400 mt-1">Available</div>` :
                    'Available';
                channelDisplay.className = 'text-xs text-gray-500 dark:text-gray-400 mt-1 flex-1';
                
                // Reset border color
                tvElement.style.borderColor = '';
                tvElement.style.borderWidth = '';
                tvElement.style.borderStyle = '';
            }
            
            // Apply color if channel has one assigned
            if (tv.assignedChannel) {
                const color = getChannelColor(tv.assignedChannel.objectId);
                if (color) {
                    tvElement.style.borderColor = color.borderTint;
                    tvElement.style.borderWidth = '3px';
                    tvElement.style.borderStyle = 'solid';
                }
            }
        }

        function updateTunerStatus() {
            const activeTuners = Object.keys(tunerAssignments).length;
            document.getElementById('tuner-status').textContent = `${activeTuners}/23 Active`;
        }

        function toggleDebugMode() {
            debugMode = !debugMode;
            const toggleButton = document.getElementById('debug-toggle');
            toggleButton.textContent = 'Debug';
            toggleButton.className = debugMode ? 
                'px-3 py-1 text-xs bg-green-100 text-green-600 dark:bg-green-900 dark:text-green-400 rounded hover:bg-green-200 dark:hover:bg-green-800 transition-colors' :
                'px-3 py-1 text-xs bg-gray-100 text-gray-600 dark:bg-gray-700 dark:text-gray-400 rounded hover:bg-gray-200 dark:hover:bg-gray-600 transition-colors';
            
            // Update all TV displays to show/hide IP addresses
            tvs.forEach(tv => {
                updateTVDisplay(tv.id);
            });
            
            renderChannels();
        }

        function simulateChannelAssignment(channel, tuner, tvId) {
            if (!tuner) return;
            
            const apiUrl = `/cgi-bin/webcmd?screen=OverviewUpd&Submit+Changes=Submit&ChObj${tuner}=${channel.objectId}&Mode${tuner}=1`;
            console.log(`API Call: ${apiUrl}`);
            
            const streamIP = `234.100.18.${tuner}`;
            const streamPort = 5000 + tuner;
            const stbCommand = `04:${streamIP}:${streamPort}`;
            console.log(`STB Command for TV ${tvId}: ${stbCommand}`);
        }

        function setFilter(filter) {
            currentFilter = filter;
            
            document.querySelectorAll('.filter-btn').forEach(btn => {
                btn.className = 'filter-btn px-3 py-1.5 text-xs font-medium rounded-lg transition-colors bg-gray-100 text-gray-700 dark:bg-gray-600 dark:text-gray-300 hover:bg-gray-200 dark:hover:bg-gray-500';
            });
            
            const filterButton = document.getElementById(`filter-${filter}`);
            if (filterButton) {
                filterButton.className = 'filter-btn px-3 py-1.5 text-xs font-medium rounded-lg transition-colors bg-primary text-white';
            }
            
            renderChannels();
        }

        function filterChannels() {
            renderChannels();
        }

        function clearAllTVs(showConfirmation = true) {
            tvs.forEach(tv => {
                tv.assignedChannel = null;
                tv.assignedTuner = null;
                updateTVDisplay(tv.id);
            });
            
            tunerAssignments = {};
            updateTunerStatus();
            selectedChannel = null;
            selectedTVForCopy = null;
            updateHeaderSelection();
            clearAllHighlights();
            renderChannels(); // Refresh to clear assignment counts
            
            if (showConfirmation) {
                showMessage('All Cleared', 'All TV assignments have been cleared.');
            }
        }

        function applyPreset(preset) {
            if (preset === 'gamenight') {
                const sportsChannels = channels.filter(ch => ch.categories.includes('sports')).slice(0, 8);
                
                clearAllTVs();
                
                sportsChannels.forEach((channel, index) => {
                    if (index < 8) {
                        const tvId = index + 1;
                        const tv = tvs.find(t => t.id === tvId);
                        const tuner = findOrAssignTuner(channel);
                        
                        tv.assignedChannel = channel;
                        tv.assignedTuner = tuner;
                        updateTVDisplay(tvId);
                    }
                });
                
                renderChannels(); // Refresh to show new assignments
                showMessage('Game Night Applied', 'Sports channels assigned to TVs 1-8');
            }
        }

        // State Save/Load Functions
        let localStorageAvailable = false;
        let memoryState = null; // Fallback to memory storage
        let autoSaveInterval = null;

        // Check if localStorage is available
        function checkLocalStorageAvailability() {
            try {
                const test = 'nsav-test';
                localStorage.setItem(test, test);
                localStorage.removeItem(test);
                localStorageAvailable = true;
                console.log('localStorage available - auto-save enabled');
                return true;
            } catch (error) {
                localStorageAvailable = false;
                console.log('localStorage not available - using memory-only storage');
                return false;
            }
        }

        function saveSystemState(manual = false) {
            const state = {
                tvAssignments: tvs.map(tv => ({
                    id: tv.id,
                    ipAddress: tv.ipAddress,
                    assignedChannel: tv.assignedChannel,
                    assignedTuner: tv.assignedTuner,
                    x: tv.x,
                    y: tv.y
                })),
                tunerAssignments: tunerAssignments,
                hiddenChannels: Array.from(hiddenChannels),
                channelColors: channelColors,
                programPrefixes: programPrefixes,
                timestamp: new Date().toISOString()
            };
            
            if (localStorageAvailable) {
                try {
                    localStorage.setItem('nsav-kontrol-state', JSON.stringify(state));
                    console.log('System state saved to localStorage');
                    
                    if (manual) {
                        showMessage('State Saved', 'Current system state has been saved to browser storage successfully.');
                    }
                } catch (error) {
                    console.error('localStorage save failed:', error);
                    // Fallback to memory
                    memoryState = state;
                    if (manual) {
                        showMessage('Save Limited', 'State saved to session memory only. Will not persist after page reload.');
                    }
                }
            } else {
                // Use memory storage as fallback
                memoryState = state;
                if (manual) {
                    showMessage('Memory Save', 'State saved to session memory. Note: Settings will not persist after page reload in this environment.');
                }
            }
        }

        function loadSystemState() {
            let state = null;
            
            if (localStorageAvailable) {
                try {
                    const savedState = localStorage.getItem('nsav-kontrol-state');
                    if (savedState) {
                        state = JSON.parse(savedState);
                        console.log('State loaded from localStorage');
                    }
                } catch (error) {
                    console.error('localStorage load failed:', error);
                }
            }
            
            // Fallback to memory state if localStorage failed or not available
            if (!state && memoryState) {
                state = memoryState;
                console.log('State loaded from memory');
            }
            
            if (!state) return false;
            
            // Restore TV positions and assignments
            if (state.tvAssignments && state.tvAssignments.length > 0) {
                // Clear current state
                clearAllTVs(false);
                
                // Restore TV positions and assignments
                state.tvAssignments.forEach(savedTV => {
                    const tv = tvs.find(t => t.id === savedTV.id);
                    if (tv) {
                        tv.x = savedTV.x || tv.x;
                        tv.y = savedTV.y || tv.y;
                        tv.assignedChannel = savedTV.assignedChannel;
                        tv.assignedTuner = savedTV.assignedTuner;
                        
                        // Update position
                        const tvElement = document.getElementById(`tv-${tv.id}`);
                        if (tvElement) {
                            tvElement.style.left = tv.x + 'px';
                            tvElement.style.top = tv.y + 'px';
                        }
                        
                        // Update display
                        updateTVDisplay(tv.id);
                    }
                });
            }
            
            // Auto-load floor plan data if embedded
            if (state.floorPlanData) {
                const img = document.getElementById('floor-plan-image');
                const placeholder = document.getElementById('floor-plan-placeholder');
                const container = document.getElementById('floor-plan-container');
                
                img.src = state.floorPlanData.dataURL;
                img.onload = function() {
                    // Hide placeholder and show container
                    placeholder.classList.add('hidden');
                    container.classList.remove('hidden');
                    
                    // Restore size and position
                    img.style.width = state.floorPlanData.width + 'px';
                    img.style.height = state.floorPlanData.height + 'px';
                    img.style.left = state.floorPlanData.x + 'px';
                    img.style.top = state.floorPlanData.y + 'px';
                    
                    // Apply inversion if needed
                    if (state.floorPlanData.inverted) {
                        img.style.filter = 'invert(1)';
                        floorPlanInverted = true;
                    }
                    
                    // Add dragging for floor plan
                    setupFloorPlanDragging(img);
                    
                    floorPlanImageLoaded = true;
                    console.log('Floor plan auto-loaded from demo state');
                };
            } else {
                // Try to auto-load from common filenames (existing behavior)
                setTimeout(() => {
                    autoLoadFloorPlan();
                }, 500);
            }
            
            // Restore other state
            if (state.tunerAssignments) {
                tunerAssignments = state.tunerAssignments;
                updateTunerStatus();
            }
            
            if (state.hiddenChannels) {
                hiddenChannels = new Set(state.hiddenChannels);
            }
            
            if (state.channelColors) {
                channelColors = state.channelColors;
            }
            
            if (state.programPrefixes) {
                programPrefixes = state.programPrefixes;
            }
            
            return true;
        }

        // Setup auto-save based on storage availability
        function setupAutoSave() {
            checkLocalStorageAvailability();
            
            // Only setup auto-save if localStorage is available
            if (localStorageAvailable) {
                autoSaveInterval = setInterval(() => {
                    saveSystemState(false);
                }, 30000);
                console.log('Auto-save enabled (every 30 seconds)');
            } else {
                console.log('Auto-save disabled - localStorage not available');
            }
        }

        function showMessage(title, message) {
            document.getElementById('modal-title').textContent = title;
            document.getElementById('modal-message').textContent = message;
            document.getElementById('custom-modal').classList.remove('hidden');
        }

        function closeModal() {
            document.getElementById('custom-modal').classList.add('hidden');
        }

        // Prefix Manager Functions
        function showPrefixManager() {
            document.getElementById('prefix-manager-modal').classList.remove('hidden');
            updateStatusMessage('Prefix Manager Active', true, 'clean');
            renderPrefixList();
        }

        function closePrefixManager() {
            document.getElementById('prefix-manager-modal').classList.add('hidden');
            updateStatusMessage('', false);
        }

        function renderPrefixList() {
            const list = document.getElementById('prefix-list');
            list.innerHTML = '';
            
            if (programPrefixes.length === 0) {
                list.innerHTML = '<div class="text-center text-gray-500 dark:text-gray-400 py-4">No prefixes configured</div>';
                return;
            }
            
            programPrefixes.forEach((prefix, index) => {
                const prefixElement = document.createElement('div');
                prefixElement.className = 'flex items-center justify-between p-3 bg-gray-50 dark:bg-gray-700 rounded-lg border border-gray-200 dark:border-gray-600';
                prefixElement.innerHTML = `
                    <span class="text-sm font-medium text-gray-900 dark:text-gray-100">"${prefix}"</span>
                    <button 
                        onclick="removePrefix(${index})" 
                        class="text-red-600 hover:text-red-700 dark:text-red-400 dark:hover:text-red-300 p-1"
                        title="Remove prefix"
                    >
                        üóëÔ∏è
                    </button>
                `;
                list.appendChild(prefixElement);
            });
        }

        function addNewPrefix() {
            const input = document.getElementById('new-prefix-input');
            const newPrefix = input.value.trim();
            
            if (!newPrefix) {
                showMessage('Invalid Input', 'Please enter a prefix to add.');
                return;
            }
            
            if (programPrefixes.includes(newPrefix)) {
                showMessage('Duplicate Prefix', 'This prefix already exists.');
                return;
            }
            
            programPrefixes.push(newPrefix);
            input.value = '';
            renderPrefixList();
        }

        function removePrefix(index) {
            programPrefixes.splice(index, 1);
            renderPrefixList();
        }

        function handlePrefixKeyPress(event) {
            if (event.key === 'Enter') {
                addNewPrefix();
            }
        }

        function resetPrefixesToDefault() {
            programPrefixes = [
                "NBA Basketball:",
                "Basketball:",
                "NFL Football:",
                "Football:",
                "MLB Baseball:",
                "Baseball:",
                "College Football:",
                "College Basketball:",
                "Soccer:",
                "Hockey:",
                "NFL RedZone",
                "SportsCenter"
            ];
            renderPrefixList();
        }

        function savePrefixChanges() {
            // Update all TV displays with new prefix settings
            tvs.forEach(tv => {
                if (tv.assignedChannel) {
                    updateTVDisplay(tv.id);
                }
            });
            
            closePrefixManager();
            showMessage('Settings Saved', 'Program prefix settings have been updated. TV displays will now use the new prefix rules.');
        }

        // Admin Mode Functions
        function toggleAdminMode() {
            adminMode = !adminMode;
            const adminControls = document.getElementById('admin-controls');
            const adminToggle = document.getElementById('admin-toggle');
            
            // Update button styling to show admin mode is active
            if (adminMode) {
                adminControls.classList.remove('hidden');
                adminToggle.className = 'px-3 py-1 text-xs bg-green-100 text-green-600 dark:bg-green-900 dark:text-green-400 rounded hover:bg-green-200 dark:hover:bg-green-800 transition-colors';
                adminToggle.innerHTML = 'üë§ Admin ON';
                updateStatusMessage('Admin Mode Active', true, 'clean');
                // No confirmation popup - streamlined workflow
            } else {
                adminControls.classList.add('hidden');
                adminToggle.className = 'px-3 py-1 text-xs bg-gray-100 text-gray-600 dark:bg-gray-700 dark:text-gray-400 rounded hover:bg-gray-200 dark:hover:bg-gray-600 transition-colors';
                adminToggle.innerHTML = 'üë§ Admin';
                updateStatusMessage('', false);
            }
            
            renderChannels();
        }

        function hideChannel(channelObjectId) {
            hiddenChannels.add(channelObjectId);
            renderChannels();
        }

        function showChannel(channelObjectId) {
            hiddenChannels.delete(channelObjectId);
            renderChannels();
        }

        function hideAllSDChannels() {
            let hiddenCount = 0;
            channels.forEach(channel => {
                if (!channel.isHD) {
                    hiddenChannels.add(channel.objectId);
                    hiddenCount++;
                }
            });
            renderChannels();
            showMessage('SD Channels Hidden', `Hidden ${hiddenCount} standard definition channels. Use individual "Show" buttons to restore specific channels.`);
        }

        // Color Management Functions
        function toggleColorMode() {
            colorMode = !colorMode;
            const toggleButton = document.getElementById('color-toggle');
            
            toggleButton.textContent = colorMode ? 'üé® Colors ON' : 'üé® Colors';
            toggleButton.className = colorMode ? 
                'px-3 py-1 text-xs bg-green-100 text-green-600 dark:bg-green-900 dark:text-green-400 rounded hover:bg-green-200 dark:hover:bg-green-800 transition-colors' :
                'px-3 py-1 text-xs bg-gray-100 text-gray-600 dark:bg-gray-700 dark:text-gray-400 rounded hover:bg-gray-200 dark:hover:bg-gray-600 transition-colors';
            
            if (colorMode) {
                // Open color picker immediately and keep it open
                renderColorPicker();
                document.getElementById('color-picker-modal').classList.remove('hidden');
                updateStatusMessage('Color Picker Active - pick a color and assign to a channel', true, 'clean');
            } else {
                // Hide the color picker modal when turning off color mode
                document.getElementById('color-picker-modal').classList.add('hidden');
                selectedChannelForColoring = null;
                selectedColorForAssignment = null;
                updateStatusMessage('', false);
            }
            
            renderChannels();
        }

        function handleChannelColorClick(channel) {
            if (!colorMode) return false;
            if (!selectedColorForAssignment) {
                showMessage('Select Color First', 'Please select a color from the color picker, then click channels to assign that color.');
                return true;
            }
            
            // Apply the selected color to this channel
            assignColorToChannel(selectedColorForAssignment, channel);
            return true;
        }

        function renderColorPicker() {
            const colorGrid = document.getElementById('color-grid');
            if (!colorGrid) {
                console.warn('Color grid element not found');
                return;
            }
            
            colorGrid.innerHTML = '';
            
            // Get already assigned colors
            const assignedColors = new Set(Object.values(channelColors));
            
            availableColors.forEach(color => {
                const colorButton = document.createElement('div');
                const isAssigned = assignedColors.has(color.name);
                const isSelected = selectedColorForAssignment === color.name;
                
                colorButton.className = `w-12 h-12 rounded-lg cursor-pointer border-2 transition-all hover:scale-110 flex items-center justify-center ${
                    isSelected ? 'border-gray-800 dark:border-gray-200 ring-4 ring-offset-2 ring-primary' : 'border-gray-300 dark:border-gray-600'
                }`;
                colorButton.style.backgroundColor = color.value;
                colorButton.onclick = () => selectColorForAssignment(color.name);
                colorButton.title = `${color.name.charAt(0).toUpperCase() + color.name.slice(1)}${isAssigned ? ' (In Use)' : ''}`;
                
                if (isAssigned) {
                    colorButton.innerHTML = '<span class="text-white font-bold text-lg">‚úó</span>';
                } else if (isSelected) {
                    colorButton.innerHTML = '<span class="text-white font-bold text-lg">‚úì</span>';
                }
                
                colorGrid.appendChild(colorButton);
            });
        }

        function selectColorForAssignment(colorName) {
            // Check if this color is already assigned to a channel
            const assignedChannelId = Object.keys(channelColors).find(id => channelColors[id] === colorName);
            
            if (assignedChannelId) {
                // Color is assigned - clicking it will unassign it
                unassignColorFromChannel(assignedChannelId, colorName);
            } else {
                // Color is not assigned - select it for assignment
                selectedColorForAssignment = colorName;
                renderColorPicker(); // Refresh to show selection
            }
        }

        function assignColorToChannel(colorName, channel) {
            // Check if color is already assigned to another channel
            const existingChannel = Object.entries(channelColors).find(([id, color]) => 
                color === colorName && parseInt(id) !== channel.objectId
            );
            
            if (existingChannel) {
                showMessage('Color Already Assigned', `This color is already assigned to another channel. Please choose a different color or clear the existing assignment first.`);
                return;
            }
            
            // Assign color
            channelColors[channel.objectId] = colorName;
            
            // Refresh display and picker
            renderColorPicker();
            renderChannels();
            updateAllTVDisplays();
            
            // No popup message - keep workflow smooth!
        }

        function unassignColorFromChannel(channelId, colorName) {
            // Find the channel that has this color assigned
            const channel = channels.find(ch => ch.objectId == channelId);
            
            // Remove the color assignment
            delete channelColors[channelId];
            
            // Clear the selected color for assignment
            selectedColorForAssignment = null;
            
            // Refresh everything
            renderColorPicker();
            renderChannels();
            updateAllTVDisplays();
            
            // No popup message - keep workflow smooth!
        }

        function clearChannelColor() {
            if (!selectedChannelForColoring) return;
            
            delete channelColors[selectedChannelForColoring.objectId];
            
            // Keep color picker open, just update the display and refresh the picker
            renderColorPicker();
            renderChannels();
            updateAllTVDisplays();
            
            showMessage('Color Cleared', `${selectedChannelForColoring.displayName} color has been cleared and reset to default.`);
        }

        function closeColorPicker() {
            document.getElementById('color-picker-modal').classList.add('hidden');
            selectedChannelForColoring = null;
        }

        function getChannelColor(channelObjectId) {
            const colorName = channelColors[channelObjectId];
            if (!colorName) return null;
            
            return availableColors.find(c => c.name === colorName);
        }

        function updateAllTVDisplays() {
            tvs.forEach(tv => {
                if (tv.assignedChannel) {
                    updateTVDisplay(tv.id);
                }
            });
        }

        function applyChannelColors() {
            // Apply colors to channel cards - only border and channel name
            channels.forEach(channel => {
                const channelElement = document.querySelector(`[data-channel-id="${channel.objectId}"]`);
                if (channelElement) {
                    const color = getChannelColor(channel.objectId);
                    if (color) {
                        // Keep original background, just add colored border
                        channelElement.style.borderLeft = `6px solid ${color.borderTint}`;
                        
                        // Color the channel name/call sign
                        const channelNameSpan = channelElement.querySelector('.channel-name');
                        if (channelNameSpan) {
                            channelNameSpan.style.color = color.borderTint;
                            channelNameSpan.style.fontWeight = 'bold';
                        }
                    } else {
                        channelElement.style.borderLeft = '';
                        const channelNameSpan = channelElement.querySelector('.channel-name');
                        if (channelNameSpan) {
                            channelNameSpan.style.color = '';
                            channelNameSpan.style.fontWeight = '';
                        }
                    }
                }
            });
            
            // Apply colors to TV borders with more forceful styling
            tvs.forEach(tv => {
                const tvElement = document.getElementById(`tv-${tv.id}`);
                if (tv.assignedChannel && tvElement) {
                    const color = getChannelColor(tv.assignedChannel.objectId);
                    if (color) {
                        // Force the border color with important declarations and direct property setting
                        tvElement.style.setProperty('border-color', color.borderTint, 'important');
                        tvElement.style.setProperty('border-width', '3px', 'important');
                        tvElement.style.setProperty('border-style', 'solid', 'important');
                    } else {
                        // Reset to default assigned TV style
                        if (tvElement.classList.contains('tv-assigned')) {
                            tvElement.style.setProperty('border-color', '#4B5563', 'important');
                            tvElement.style.setProperty('border-width', '2px', 'important');
                            tvElement.style.setProperty('border-style', 'solid', 'important');
                        }
                    }
                } else if (tvElement) {
                    // Clear any custom border styling for unassigned TVs
                    tvElement.style.removeProperty('border-color');
                    tvElement.style.removeProperty('border-width');
                    tvElement.style.removeProperty('border-style');
                }
            });
        }

        // Sports Content Detection Functions
        function isFootballContent(programTitle) {
            const footballTerms = ['vs', 'Cowboys', 'Giants', 'Chiefs', 'Bills', 'NFL', 'Football', 'College Gameday', 'GameDay'];
            return footballTerms.some(term => programTitle.includes(term));
        }

        function isBasketballContent(programTitle) {
            const basketballTerms = ['Lakers', 'Warriors', 'Duke', 'Carolina', 'Knicks', 'Nets', 'Celtics', 'Heat', 'NBA', 'Basketball', 'March Madness'];
            return basketballTerms.some(term => programTitle.includes(term));
        }

        function isBaseballContent(programTitle) {
            const baseballTerms = ['Yankees', 'Red Sox', 'Baseball', 'MLB', 'Quick Pitch'];
            return baseballTerms.some(term => programTitle.includes(term));
        }

        function isSoccerContent(programTitle) {
            const soccerTerms = ['Soccer', 'Premier League', 'MLS', 'World Cup', 'UEFA', 'Champions League', 'La Liga', 'Serie A', 'Bundesliga', 'EPL', 'English Premier'];
            return soccerTerms.some(term => programTitle.includes(term));
        }

        function isHockeyContent(programTitle) {
            const hockeyTerms = ['Hockey', 'NHL', 'Stanley Cup', 'Rangers vs Kings', 'Bruins', 'Blackhawks', 'Penguins', 'Capitals', 'Lightning'];
            return hockeyTerms.some(term => programTitle.includes(term));
        }

        function isMMAContent(programTitle) {
            const mmaTerms = ['UFC', 'MMA', 'Mixed Martial Arts', 'Fight Night', 'Octagon', 'Dana White', 'Conor McGregor', 'Jon Jones'];
            return mmaTerms.some(term => programTitle.includes(term));
        }

        // Dynamic Sports Filter Creation
        function updateSportsFilters() {
            const sportsChannels = channels.filter(ch => ch.categories.includes('sports'));
            
            // Check what sports are currently playing
            const activeSports = {
                football: sportsChannels.some(ch => isFootballContent(ch.program.current)),
                basketball: sportsChannels.some(ch => isBasketballContent(ch.program.current)),
                baseball: sportsChannels.some(ch => isBaseballContent(ch.program.current)),
                soccer: sportsChannels.some(ch => isSoccerContent(ch.program.current)),
                hockey: sportsChannels.some(ch => isHockeyContent(ch.program.current)),
                mma: sportsChannels.some(ch => isMMAContent(ch.program.current))
            };

            // Get the filter button container
            const filterContainer = document.querySelector('.flex.flex-wrap.gap-1');
            
            // Remove existing sport-specific buttons
            ['football', 'basketball', 'baseball', 'soccer', 'hockey', 'mma'].forEach(sport => {
                const existingBtn = document.getElementById(`filter-${sport}`);
                if (existingBtn) existingBtn.remove();
            });

            // Add active sport buttons after the News button
            const newsButton = document.getElementById('filter-news');
            let lastSportBtn = newsButton;

            if (activeSports.football) {
                const footballBtn = document.createElement('button');
                footballBtn.onclick = () => setFilter('football');
                footballBtn.id = 'filter-football';
                footballBtn.className = 'filter-btn px-3 py-1.5 text-xs font-medium rounded-lg transition-colors bg-gray-100 text-gray-700 dark:bg-gray-600 dark:text-gray-300 hover:bg-gray-200 dark:hover:bg-gray-500';
                footballBtn.textContent = 'üèà Football';
                lastSportBtn.parentNode.insertBefore(footballBtn, lastSportBtn.nextSibling);
                lastSportBtn = footballBtn;
            }

            if (activeSports.basketball) {
                const basketballBtn = document.createElement('button');
                basketballBtn.onclick = () => setFilter('basketball');
                basketballBtn.id = 'filter-basketball';
                basketballBtn.className = 'filter-btn px-3 py-1.5 text-xs font-medium rounded-lg transition-colors bg-gray-100 text-gray-700 dark:bg-gray-600 dark:text-gray-300 hover:bg-gray-200 dark:hover:bg-gray-500';
                basketballBtn.textContent = 'üèÄ Basketball';
                lastSportBtn.parentNode.insertBefore(basketballBtn, lastSportBtn.nextSibling);
                lastSportBtn = basketballBtn;
            }

            if (activeSports.baseball) {
                const baseballBtn = document.createElement('button');
                baseballBtn.onclick = () => setFilter('baseball');
                baseballBtn.id = 'filter-baseball';
                baseballBtn.className = 'filter-btn px-3 py-1.5 text-xs font-medium rounded-lg transition-colors bg-gray-100 text-gray-700 dark:bg-gray-600 dark:text-gray-300 hover:bg-gray-200 dark:hover:bg-gray-500';
                baseballBtn.textContent = '‚öæ Baseball';
                lastSportBtn.parentNode.insertBefore(baseballBtn, lastSportBtn.nextSibling);
                lastSportBtn = baseballBtn;
            }

            if (activeSports.soccer) {
                const soccerBtn = document.createElement('button');
                soccerBtn.onclick = () => setFilter('soccer');
                soccerBtn.id = 'filter-soccer';
                soccerBtn.className = 'filter-btn px-3 py-1.5 text-xs font-medium rounded-lg transition-colors bg-gray-100 text-gray-700 dark:bg-gray-600 dark:text-gray-300 hover:bg-gray-200 dark:hover:bg-gray-500';
                soccerBtn.textContent = '‚öΩ Soccer';
                lastSportBtn.parentNode.insertBefore(soccerBtn, lastSportBtn.nextSibling);
                lastSportBtn = soccerBtn;
            }

            if (activeSports.hockey) {
                const hockeyBtn = document.createElement('button');
                hockeyBtn.onclick = () => setFilter('hockey');
                hockeyBtn.id = 'filter-hockey';
                hockeyBtn.className = 'filter-btn px-3 py-1.5 text-xs font-medium rounded-lg transition-colors bg-gray-100 text-gray-700 dark:bg-gray-600 dark:text-gray-300 hover:bg-gray-200 dark:hover:bg-gray-500';
                hockeyBtn.textContent = 'üèí Hockey';
                lastSportBtn.parentNode.insertBefore(hockeyBtn, lastSportBtn.nextSibling);
                lastSportBtn = hockeyBtn;
            }

            if (activeSports.mma) {
                const mmaBtn = document.createElement('button');
                mmaBtn.onclick = () => setFilter('mma');
                mmaBtn.id = 'filter-mma';
                mmaBtn.className = 'filter-btn px-3 py-1.5 text-xs font-medium rounded-lg transition-colors bg-gray-100 text-gray-700 dark:bg-gray-600 dark:text-gray-300 hover:bg-gray-200 dark:hover:bg-gray-500';
                mmaBtn.textContent = 'ü•ä MMA';
                lastSportBtn.parentNode.insertBefore(mmaBtn, lastSportBtn.nextSibling);
                lastSportBtn = mmaBtn;
            }
        }

        // Help Functions
        function showHelp() {
            document.getElementById('help-modal').classList.remove('hidden');
        }

        function closeHelp() {
            document.getElementById('help-modal').classList.add('hidden');
        }

        // TV Setup Functions
        function showTVSetup() {
            document.getElementById('tv-setup-modal').classList.remove('hidden');
            updateTVConfiguration();
        }

        function closeTVSetup() {
            document.getElementById('tv-setup-modal').classList.add('hidden');
        }

        function updateTVConfiguration() {
            const tvCount = parseInt(document.getElementById('tv-count-input').value);
            const ipContainer = document.getElementById('ip-assignments');
            
            ipContainer.innerHTML = '';
            
            for (let i = 1; i <= tvCount; i++) {
                const ipAddress = `192.168.3.${100 + i}`;
                const ipElement = document.createElement('div');
                ipElement.className = 'flex items-center justify-between p-3 bg-white dark:bg-gray-700 rounded-lg border border-gray-200 dark:border-gray-600';
                ipElement.innerHTML = `
                    <div class="flex items-center space-x-3">
                        <span class="text-sm font-bold text-gray-600 dark:text-gray-400 w-12">TV ${i}</span>
                        <span class="text-sm font-medium text-gray-900 dark:text-gray-100">${ipAddress}</span>
                    </div>
                    <span class="text-xs text-green-600 dark:text-green-400 font-medium">‚úì Ready</span>
                `;
                ipContainer.appendChild(ipElement);
            }
        }

        function applyTVCount() {
            const tvCount = parseInt(document.getElementById('tv-count-input').value);
            
            if (tvCount < 1 || tvCount > 100) {
                showMessage('Invalid TV Count', 'Please enter a number between 1 and 100.');
                return;
            }
            
            // Clear existing assignments and reset
            clearAllTVs();
            
            // Recreate TV grid with new count
            createTVGrid(tvCount);
            
            updateTVConfiguration();
            
            showMessage('Configuration Applied', `TV layout updated for ${tvCount} displays. IP addresses assigned from 192.168.3.101 to 192.168.3.${100 + tvCount}. TVs are positioned in floor plan area and can be dragged to arrange.`);
        }

        function saveTVConfiguration() {
            const tvCount = parseInt(document.getElementById('tv-count-input').value);
            
            // Store configuration (in a real app, this would save to backend)
            console.log(`TV Configuration Saved: ${tvCount} TVs`);
            
            tvs.forEach(tv => {
                console.log(`TV ${tv.id}: ${tv.ipAddress}`);
            });
            
            closeTVSetup();
            showMessage('Configuration Saved', `TV setup saved for ${tvCount} displays. You can now configure the STB-6500 decoders using the assigned IP addresses.`);
        }

        function exportConfiguration() {
            const tvCount = parseInt(document.getElementById('tv-count-input').value);
            let configText = `NSAV KONTROL - TV Setup Configuration\n`;
            configText += `Generated: ${new Date().toLocaleString()}\n\n`;
            configText += `Network Configuration:\n`;
            configText += `Router: 192.168.3.1\n`;
            configText += `COM Headend: 192.168.3.18\n`;
            configText += `Subnet Mask: 255.255.255.0\n\n`;
            configText += `STB-6500 IP Assignments:\n`;
            configText += `================================\n`;
            
            for (let i = 1; i <= tvCount; i++) {
                configText += `TV ${i}: 192.168.3.${100 + i}\n`;
            }
            
            configText += `\nSetup Instructions:\n`;
            configText += `1. Connect each STB-6500 to the network\n`;
            configText += `2. Run built-in setup on each decoder\n`;
            configText += `3. Assign matching IP address from above\n`;
            configText += `4. Configure subnet mask: 255.255.255.0\n`;
            configText += `5. Configure gateway: 192.168.3.1\n`;
            configText += `6. Test connectivity and deploy!\n`;
            
            // Create download link
            const blob = new Blob([configText], { type: 'text/plain' });
            const url = window.URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `NSAV-TV-Config-${tvCount}TVs.txt`;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            window.URL.revokeObjectURL(url);
            
            showMessage('Configuration Exported', 'TV setup configuration has been downloaded as a text file.');
        }

        // Export Demo Package Function
        function exportDemoPackage() {
            // Capture floor plan as base64 if loaded
            let floorPlanData = null;
            if (floorPlanImageLoaded) {
                const img = document.getElementById('floor-plan-image');
                if (img && img.src) {
                    // Convert image to base64 for embedding
                    const canvas = document.createElement('canvas');
                    const ctx = canvas.getContext('2d');
                    canvas.width = img.naturalWidth;
                    canvas.height = img.naturalHeight;
                    ctx.drawImage(img, 0, 0);
                    
                    try {
                        floorPlanData = {
                            dataURL: canvas.toDataURL('image/png'),
                            width: parseInt(img.style.width) || img.clientWidth,
                            height: parseInt(img.style.height) || img.clientHeight,
                            x: parseInt(img.style.left) || 0,
                            y: parseInt(img.style.top) || 0,
                            inverted: floorPlanInverted
                        };
                    } catch (error) {
                        console.log('Could not embed floor plan - will use filename detection instead');
                    }
                }
            }
            
            // Capture current complete state
            const demoState = {
                tvAssignments: tvs.map(tv => ({
                    id: tv.id,
                    ipAddress: tv.ipAddress,
                    assignedChannel: tv.assignedChannel,
                    assignedTuner: tv.assignedTuner,
                    x: tv.x,
                    y: tv.y
                })),
                tunerAssignments: tunerAssignments,
                hiddenChannels: Array.from(hiddenChannels),
                channelColors: channelColors,
                programPrefixes: programPrefixes,
                textLabels: textLabels,
                drawnShapes: drawnShapes,
                presets: presets,
                activePreset: activePreset,
                floorPlanSettings: {
                    imageLoaded: floorPlanImageLoaded,
                    inverted: floorPlanInverted
                },
                floorPlanData: floorPlanData,
                exportTimestamp: new Date().toISOString(),
                exportVersion: '1.1'
            };

            // Create instructions
            const assignedTVs = demoState.tvAssignments.filter(tv => tv.assignedChannel).length;
            const instructions = `AV GAME CHANGER - DEMO PACKAGE
Generated: ${new Date().toLocaleString()}

WHAT'S INCLUDED:
===============
üì¶ demo-state.json - Your complete configuration
üìã README.txt - This instruction file

YOUR DEMO CONFIGURATION:
========================
üñ•Ô∏è  ${assignedTVs} TVs with channel assignments
üé® ${Object.keys(demoState.channelColors).length} custom channel colors  
üìù ${demoState.textLabels.length} text labels
üéØ ${demoState.drawnShapes.length} drawn annotations
üì∫ ${Object.keys(demoState.tunerAssignments).length} active tuners
üö´ ${demoState.hiddenChannels.length} hidden channels

SETUP INSTRUCTIONS:
==================
1. Create a folder called "AV-Demo"
2. Copy your HTML file into the folder
3. Copy demo-state.json into the same folder  
4. (Optional) Add your floor plan as "floorplan.jpg"
5. Modify the HTML file to auto-load this state
6. Open in any browser - demo runs perfectly!

CODE TO ADD TO YOUR HTML:
========================
Add this to the top of your <script> section:

// Auto-load demo state
const DEMO_STATE_FILE = 'demo-state.json';

async function loadDemoFromFile() {
    try {
        const response = await fetch(DEMO_STATE_FILE);
        if (response.ok) {
            const demoState = await response.json();
            restoreDemoState(demoState);
            console.log('Demo state loaded successfully!');
        }
    } catch (error) {
        console.log('Demo state file not found - starting fresh');
    }
}

// Call this after your normal initialization
document.addEventListener('DOMContentLoaded', () => {
    initApp();
    setTimeout(loadDemoFromFile, 500);
});

SHARING YOUR DEMO:
=================
‚úÖ Zip the folder and email it
‚úÖ Host on any web server
‚úÖ Works offline - no internet required!
‚úÖ Runs on any device with a browser

NEED HELP?
==========
üìû Support: (818) 729-8554
üìß Email: support@nsav.com
üåê Web: nsav.com

You're about to DESTROY the competition! üöÄ
NSAV - The future of AV control is here!`;

            // Download instructions
            const instructionsBlob = new Blob([instructions], { type: 'text/plain' });
            const instructionsUrl = window.URL.createObjectURL(instructionsBlob);
            const instructionsLink = document.createElement('a');
            instructionsLink.href = instructionsUrl;
            instructionsLink.download = 'README.txt';
            document.body.appendChild(instructionsLink);
            instructionsLink.click();
            document.body.removeChild(instructionsLink);
            window.URL.revokeObjectURL(instructionsUrl);

            // Download demo state
            const stateBlob = new Blob([JSON.stringify(demoState, null, 2)], { type: 'application/json' });
            const stateUrl = window.URL.createObjectURL(stateBlob);
            const stateLink = document.createElement('a');
            stateLink.href = stateUrl;
            stateLink.download = 'demo-state.json';
            document.body.appendChild(stateLink);
            stateLink.click();
            document.body.removeChild(stateLink);
            window.URL.revokeObjectURL(stateUrl);

            showMessage('üöÄ Demo Package Created!', 
                `Your demo configuration exported successfully! ${assignedTVs} TV assignments and all settings saved. Check the README.txt for setup instructions.`);
        }

        // Floor Plan Functions
        let floorPlanImageLoaded = false;
        let floorPlanInverted = false;

        function loadFloorPlan(event) {
            if (!adminMode) {
                showMessage('Admin Mode Required', 'Please enable Admin Mode to load floor plans.');
                return;
            }
            
            const file = event.target.files[0];
            if (!file) return;
            
            if (!file.type.startsWith('image/')) {
                showMessage('Invalid File', 'Please select an image file (PNG, JPG, GIF, etc.)');
                return;
            }
            
            const reader = new FileReader();
            reader.onload = function(e) {
                const img = document.getElementById('floor-plan-image');
                const placeholder = document.getElementById('floor-plan-placeholder');
                const container = document.getElementById('floor-plan-container');
                
                img.src = e.target.result;
                img.onload = function() {
                    // Hide placeholder and show container
                    placeholder.classList.add('hidden');
                    container.classList.remove('hidden');
                    
                    // Set initial size and position
                    resetImageSize();
                    img.style.left = '0px';
                    img.style.top = '0px';
                    
                    // Add dragging for floor plan
                    setupFloorPlanDragging(img);
                    
                    floorPlanImageLoaded = true;
                    showMessage('Floor Plan Loaded', 'Your floor plan has been loaded successfully. You can now drag it to position it properly. Use the Size Controls to adjust size and inversion settings.');
                };
            };
            reader.readAsDataURL(file);
        }
        
        function setupFloorPlanDragging(img) {
            let isDraggingFloorPlan = false;
            let floorPlanDragStartX, floorPlanDragStartY, floorPlanStartLeft, floorPlanStartTop;
            const workspace = document.getElementById('floor-plan-workspace');
            
            // Mouse down handler for floor plan
            img.addEventListener('mousedown', (e) => {
                // CRITICAL: Don't interfere if drawing mode is active
                if (drawingMode) {
                    return; // Let drawing system handle it
                }
                
                if (e.button === 0 && adminMode) { // Only allow dragging in admin mode
                    isDraggingFloorPlan = true;
                    floorPlanDragStartX = e.clientX;
                    floorPlanDragStartY = e.clientY;
                    floorPlanStartLeft = parseInt(img.style.left) || 0;
                    floorPlanStartTop = parseInt(img.style.top) || 0;
                    img.style.zIndex = '5'; // Below TVs but above background
                    img.style.opacity = '0.9';
                    img.style.cursor = 'grabbing';
                    e.preventDefault();
                    e.stopPropagation();
                }
            });
            
            // Touch start handler for floor plan
            img.addEventListener('touchstart', (e) => {
                if (adminMode) { // Only allow touch dragging in admin mode
                    isDraggingFloorPlan = true;
                    const touch = e.touches[0];
                    floorPlanDragStartX = touch.clientX;
                    floorPlanDragStartY = touch.clientY;
                    floorPlanStartLeft = parseInt(img.style.left) || 0;
                    floorPlanStartTop = parseInt(img.style.top) || 0;
                    img.style.zIndex = '5'; // Below TVs but above background
                    img.style.opacity = '0.9';
                    e.preventDefault();
                    e.stopPropagation();
                }
            });
            
            // Mouse move handler for floor plan
            const handleFloorPlanMouseMove = (e) => {
                if (isDraggingFloorPlan) {
                    const deltaX = e.clientX - floorPlanDragStartX;
                    const deltaY = e.clientY - floorPlanDragStartY;
                    
                    // Calculate new position with bounds checking
                    const newLeft = Math.max(
                        -(img.clientWidth - 200), // Allow dragging mostly off-screen to the left
                        Math.min(
                            workspace.clientWidth - 200, // Allow dragging mostly off-screen to the right
                            floorPlanStartLeft + deltaX
                        )
                    );
                    
                    const newTop = Math.max(
                        -(img.clientHeight - 200), // Allow dragging mostly off-screen upward
                        Math.min(
                            workspace.clientHeight - 200, // Allow dragging mostly off-screen downward
                            floorPlanStartTop + deltaY
                        )
                    );
                    
                    img.style.left = newLeft + 'px';
                    img.style.top = newTop + 'px';
                    e.preventDefault();
                }
            };
            
            // Touch move handler for floor plan
            const handleFloorPlanTouchMove = (e) => {
                if (isDraggingFloorPlan) {
                    const touch = e.touches[0];
                    const deltaX = touch.clientX - floorPlanDragStartX;
                    const deltaY = touch.clientY - floorPlanDragStartY;
                    
                    // Calculate new position with bounds checking
                    const newLeft = Math.max(
                        -(img.clientWidth - 200), // Allow dragging mostly off-screen to the left
                        Math.min(
                            workspace.clientWidth - 200, // Allow dragging mostly off-screen to the right
                            floorPlanStartLeft + deltaX
                        )
                    );
                    
                    const newTop = Math.max(
                        -(img.clientHeight - 200), // Allow dragging mostly off-screen upward
                        Math.min(
                            workspace.clientHeight - 200, // Allow dragging mostly off-screen downward
                            floorPlanStartTop + deltaY
                        )
                    );
                    
                    img.style.left = newLeft + 'px';
                    img.style.top = newTop + 'px';
                    e.preventDefault();
                }
            };
            
            // Mouse up handler for floor plan
            const handleFloorPlanMouseUp = (e) => {
                if (isDraggingFloorPlan) {
                    isDraggingFloorPlan = false;
                    img.style.zIndex = '1';
                    img.style.opacity = '1';
                    img.style.cursor = 'move';
                    e.preventDefault();
                }
            };
            
            // Touch end handler for floor plan
            const handleFloorPlanTouchEnd = (e) => {
                if (isDraggingFloorPlan) {
                    isDraggingFloorPlan = false;
                    img.style.zIndex = '1';
                    img.style.opacity = '1';
                    e.preventDefault();
                }
            };
            
            // Attach floor plan drag listeners
            document.addEventListener('mousemove', handleFloorPlanMouseMove);
            document.addEventListener('mouseup', handleFloorPlanMouseUp);
            document.addEventListener('touchmove', handleFloorPlanTouchMove, { passive: false });
            document.addEventListener('touchend', handleFloorPlanTouchEnd);
        }

        function toggleImageInvert() {
            if (!adminMode) {
                showMessage('Admin Mode Required', 'Please enable Admin Mode to modify floor plan settings.');
                return;
            }
            
            if (!floorPlanImageLoaded) {
                showMessage('No Image Loaded', 'Please load a floor plan image first.');
                return;
            }
            
            const img = document.getElementById('floor-plan-image');
            const controlBtn = document.getElementById('invert-control-btn');
            
            floorPlanInverted = !floorPlanInverted;
            
            if (floorPlanInverted) {
                img.style.filter = 'invert(1)';
                if (controlBtn) controlBtn.textContent = '‚ö™ Normal Mode';
            } else {
                img.style.filter = '';
                if (controlBtn) controlBtn.textContent = 'üîÑ Toggle Invert';
            }
        }

        function showFloorPlanControls() {
            if (!adminMode) {
                showMessage('Admin Mode Required', 'Please enable Admin Mode to access floor plan controls.');
                return;
            }
            
            if (!floorPlanImageLoaded) {
                showMessage('No Image Loaded', 'Please load a floor plan image first.');
                return;
            }
            
            // Update current values in the modal
            const img = document.getElementById('floor-plan-image');
            document.getElementById('image-width').value = Math.round(img.clientWidth);
            document.getElementById('image-height').value = Math.round(img.clientHeight);
            
            document.getElementById('floor-plan-controls-modal').classList.remove('hidden');
            updateStatusMessage('Floor Plan Controls Active', true, 'clean');
        }

        function closeFloorPlanControls() {
            document.getElementById('floor-plan-controls-modal').classList.add('hidden');
            updateStatusMessage('', false);
        }

        function updateImageSize() {
            if (!floorPlanImageLoaded) return;
            
            const img = document.getElementById('floor-plan-image');
            const widthInput = document.getElementById('image-width');
            const heightInput = document.getElementById('image-height');
            const maintainAspect = document.getElementById('maintain-aspect').checked;
            
            const newWidth = parseInt(widthInput.value);
            const newHeight = parseInt(heightInput.value);
            
            if (maintainAspect) {
                // Calculate aspect ratio based on natural dimensions
                const naturalRatio = img.naturalWidth / img.naturalHeight;
                
                // If width was changed, adjust height
                if (document.activeElement === widthInput) {
                    const calculatedHeight = Math.round(newWidth / naturalRatio);
                    heightInput.value = calculatedHeight;
                    img.style.width = newWidth + 'px';
                    img.style.height = calculatedHeight + 'px';
                } else {
                    // If height was changed, adjust width
                    const calculatedWidth = Math.round(newHeight * naturalRatio);
                    widthInput.value = calculatedWidth;
                    img.style.width = calculatedWidth + 'px';
                    img.style.height = newHeight + 'px';
                }
            } else {
                // Free resize
                img.style.width = newWidth + 'px';
                img.style.height = newHeight + 'px';
            }
        }

        function setImageSize(width, height) {
            if (!floorPlanImageLoaded) return;
            
            const img = document.getElementById('floor-plan-image');
            const widthInput = document.getElementById('image-width');
            const heightInput = document.getElementById('image-height');
            
            img.style.width = width + 'px';
            img.style.height = height + 'px';
            widthInput.value = width;
            heightInput.value = height;
        }

        function resetImageSize() {
            if (!floorPlanImageLoaded) return;
            
            const img = document.getElementById('floor-plan-image');
            const widthInput = document.getElementById('image-width');
            const heightInput = document.getElementById('image-height');
            
            // Reset to a good default size (1000px width, maintaining aspect ratio)
            const naturalRatio = img.naturalWidth / img.naturalHeight;
            const defaultWidth = Math.min(1000, img.naturalWidth);
            const defaultHeight = Math.round(defaultWidth / naturalRatio);
            
            img.style.width = defaultWidth + 'px';
            img.style.height = defaultHeight + 'px';
            widthInput.value = defaultWidth;
            heightInput.value = defaultHeight;
        }

        // Text Insertion Functions
        let textLabels = [];
        let selectedTextColor = 'white';

        function showTextInsertion() {
            document.getElementById('text-insertion-modal').classList.remove('hidden');
            updateStatusMessage('Text Insertion Active', true, 'clean');
            // Focus on the text input for better UX
            setTimeout(() => {
                document.getElementById('text-label-input').focus();
            }, 100);
        }

        function closeTextInsertion() {
            document.getElementById('text-insertion-modal').classList.add('hidden');
            updateStatusMessage('', false);
            // Clear the input
            document.getElementById('text-label-input').value = '';
            selectedTextColor = 'white';
        }

        function handleTextKeyPress(event) {
            if (event.key === 'Enter') {
                insertTextLabel();
            }
        }

        function setTextColor(color) {
            selectedTextColor = color;
            // Update visual feedback
            document.querySelectorAll('#text-insertion-modal .grid button').forEach(btn => {
                btn.classList.remove('ring-2', 'ring-primary');
            });
            event.target.classList.add('ring-2', 'ring-primary');
        }

        function insertTextLabel() {
            const textInput = document.getElementById('text-label-input');
            const sizeSelect = document.getElementById('text-size-select');
            const text = textInput.value.trim();
            
            if (!text) {
                showMessage('Empty Text', 'Please enter some text for the label.');
                return;
            }
            
            const workspace = document.getElementById('floor-plan-workspace');
            const textElement = document.createElement('div');
            
            // Generate unique ID
            const textId = `text-label-${Date.now()}`;
            textElement.id = textId;
            
            // Set up the text element with dragging capability
            textElement.className = `absolute cursor-move pointer-events-auto font-bold select-none ${sizeSelect.value}`;
            textElement.style.color = getTextColorValue(selectedTextColor);
            textElement.style.textShadow = '1px 1px 2px rgba(0,0,0,0.8)'; // Better visibility
            textElement.style.zIndex = '15'; // Above TVs
            textElement.textContent = text;
            
            // Position in the center of the workspace
            const centerX = (workspace.clientWidth - 200) / 2; // Estimate text width
            const centerY = workspace.clientHeight / 2;
            textElement.style.left = centerX + 'px';
            textElement.style.top = centerY + 'px';
            
            // Add dragging functionality
            setupTextLabelDragging(textElement);
            
            // Add double-click to edit/delete
            textElement.ondblclick = (e) => {
                if (adminMode) {
                    editTextLabel(textId);
                    e.stopPropagation();
                }
            };
            
            // Store in array
            textLabels.push({
                id: textId,
                text: text,
                color: selectedTextColor,
                size: sizeSelect.value,
                x: centerX,
                y: centerY
            });
            
            // Add to workspace
            workspace.appendChild(textElement);
            
            closeTextInsertion();
            showMessage('Text Added', 'Text label added to floor plan. You can drag it to reposition. Double-click in admin mode to edit or delete.');
        }

        function getTextColorValue(colorName) {
            const colorMap = {
                'white': '#FFFFFF',
                'yellow': '#FDE047',
                'red': '#EF4444',
                'blue': '#3B82F6',
                'green': '#22C55E',
                'purple': '#A855F7'
            };
            return colorMap[colorName] || '#FFFFFF';
        }

        function setupTextLabelDragging(element) {
            let isDraggingText = false;
            let textDragStartX, textDragStartY, textStartLeft, textStartTop;
            
            element.addEventListener('mousedown', (e) => {
                if (e.button === 0 && adminMode) {
                    isDraggingText = true;
                    textDragStartX = e.clientX;
                    textDragStartY = e.clientY;
                    textStartLeft = parseInt(element.style.left) || 0;
                    textStartTop = parseInt(element.style.top) || 0;
                    element.style.zIndex = '1000';
                    element.style.opacity = '0.8';
                    e.preventDefault();
                    e.stopPropagation();
                }
            });
            
            const handleTextMouseMove = (e) => {
                if (isDraggingText) {
                    const deltaX = e.clientX - textDragStartX;
                    const deltaY = e.clientY - textDragStartY;
                    
                    const workspace = document.getElementById('floor-plan-workspace');
                    const newLeft = Math.max(0, Math.min(textStartLeft + deltaX, workspace.clientWidth - 50));
                    const newTop = Math.max(0, Math.min(textStartTop + deltaY, workspace.clientHeight - 20));
                    
                    element.style.left = newLeft + 'px';
                    element.style.top = newTop + 'px';
                    e.preventDefault();
                }
            };
            
            const handleTextMouseUp = (e) => {
                if (isDraggingText) {
                    isDraggingText = false;
                    element.style.zIndex = '15';
                    element.style.opacity = '1';
                    
                    // Update stored position
                    const labelData = textLabels.find(label => label.id === element.id);
                    if (labelData) {
                        labelData.x = parseInt(element.style.left);
                        labelData.y = parseInt(element.style.top);
                    }
                    e.preventDefault();
                }
            };
            
            document.addEventListener('mousemove', handleTextMouseMove);
            document.addEventListener('mouseup', handleTextMouseUp);
        }

        function editTextLabel(textId) {
            const labelData = textLabels.find(label => label.id === textId);
            if (!labelData) return;
            
            // Simple edit dialog using a custom modal would be ideal, but for now use the insertion modal
            document.getElementById('text-label-input').value = labelData.text;
            document.getElementById('text-size-select').value = labelData.size;
            selectedTextColor = labelData.color;
            
            // Remove the old label
            const element = document.getElementById(textId);
            if (element) element.remove();
            textLabels = textLabels.filter(label => label.id !== textId);
            
            showTextInsertion();
        }

        // Onboarding Tour System
        let currentTourStep = 1;
        let tourActive = false;
        const totalTourSteps = 6;

        const tourSteps = [
            {
                title: "üéÆ Basic Channel Assignment",
                content: `
                    <div class="space-y-4">
                        <div class="bg-purple-50 dark:bg-purple-900/20 p-4 rounded-lg border border-purple-200 dark:border-purple-800">
                            <h4 class="font-semibold text-purple-700 dark:text-purple-300 mb-2">Channel ‚Üí TV Assignment</h4>
                            <ol class="list-decimal list-inside space-y-2 text-sm text-purple-600 dark:text-purple-400">
                                <li><strong>Click any channel card</strong> on the right</li>
                                <li><strong>Blue highlights appear</strong> on TVs with that channel</li>
                                <li><strong>Click any TV</strong> to assign the channel</li>
                                <li><strong>Click more TVs</strong> to assign to multiple displays</li>
                                <li><strong>Selection auto-expires</strong> after 5 seconds or click floor plan to cancel</li>
                            </ol>
                        </div>
                        <p class="text-sm text-gray-600 dark:text-gray-400"><strong>Pro tip:</strong> This workflow lets you rapid-fire assign one channel to many TVs without constantly re-selecting!</p>
                    </div>
                `,
                highlight: "#channel-grid"
            },
            {
                title: "üîÑ TV-to-TV Copying",
                content: `
                    <div class="space-y-4">
                        <p class="text-lg"><strong>Copy channels between TVs instantly!</strong></p>
                        <div class="bg-orange-50 dark:bg-orange-900/20 p-4 rounded-lg border border-orange-200 dark:border-orange-800">
                            <h4 class="font-semibold text-orange-700 dark:text-orange-300 mb-2">TV ‚Üí TV Copying</h4>
                            <ol class="list-decimal list-inside space-y-2 text-sm text-orange-600 dark:text-orange-400">
                                <li><strong>Click any TV</strong> that has a channel assigned</li>
                                <li><strong>Orange highlight appears</strong> - it's now in "copy mode"</li>
                                <li><strong>Click target TVs</strong> to copy the channel to them</li>
                                <li><strong>Source stays selected</strong> for multiple copies</li>
                            </ol>
                        </div>
                        <p class="text-sm text-gray-600 dark:text-gray-400"><strong>Pro tip:</strong> Quickly route programs without finding the channel in the guide.</p>
                    </div>
                `,
                highlight: "#tv-grid"
            },
            {
                title: "üë§ Admin Mode - Hidden Powers",
                content: `
                    <div class="space-y-4">
                        <p class="text-lg"><strong>Unlock advanced features!</strong></p>
                        <div class="bg-green-50 dark:bg-green-900/20 p-4 rounded-lg border border-green-200 dark:border-green-800">
                            <h4 class="font-semibold text-green-700 dark:text-green-300 mb-2">Admin Features</h4>
                            <ul class="list-disc list-inside space-y-2 text-sm text-green-600 dark:text-green-400">
                                <li><strong>Floor Plan Upload:</strong> Admin ‚Üí Load Floor Plan</li>
                                <li><strong>TV Dragging:</strong> Drag TVs to position (Admin mode only)</li>
                                <li><strong>Text Labels:</strong> Admin controls ‚Üí Insert Text</li>
                                <li><strong>Channel Management:</strong> Hide/show channels</li>
                                <li><strong>Bulk Operations:</strong> Hide all SD channels</li>
                            </ul>
                        </div>
                        <p class="text-sm text-gray-600 dark:text-gray-400"><strong>Remember:</strong> Many features require Admin Mode to be enabled first!</p>
                    </div>
                `,
                highlight: "#admin-toggle"
            },
            {
                title: "üé® Color Management System",
                content: `
                    <div class="space-y-4">
                        <p class="text-lg"><strong>Visual organization for busy venues!</strong></p>
                        <div class="bg-pink-50 dark:bg-pink-900/20 p-4 rounded-lg border border-pink-200 dark:border-pink-800">
                            <h4 class="font-semibold text-pink-700 dark:text-pink-300 mb-2">Color Workflow</h4>
                            <ol class="list-decimal list-inside space-y-2 text-sm text-pink-600 dark:text-pink-400">
                                <li><strong>Click üé® Colors</strong> - picker opens and stays open</li>
                                <li><strong>Click channel cards</strong> - picker updates</li>
                                <li><strong>Pick colors</strong> - applied instantly to channel + TVs</li>
                                <li><strong>Keep assigning</strong> - no more opening/closing!</li>
                                <li><strong>Click Colors again</strong> - picker closes</li>
                            </ol>
                        </div>
                        <p class="text-sm text-gray-600 dark:text-gray-400"><strong>Use case:</strong> Color-code sports (red), news (blue), entertainment (green) for instant visual recognition!</p>
                    </div>
                `,
                highlight: "#color-toggle"
            },
            {
                title: "üîç Smart Search & Filtering",
                content: `
                    <div class="space-y-4">
                        <p class="text-lg"><strong>Find channels instantly!</strong></p>
                        <div class="bg-blue-50 dark:bg-blue-900/20 p-4 rounded-lg border border-blue-200 dark:border-blue-800">
                            <h4 class="font-semibold text-blue-700 dark:text-blue-300 mb-2">Search Everything</h4>
                            <ul class="list-disc list-inside space-y-2 text-sm text-blue-600 dark:text-blue-400">
                                <li><strong>Channel names:</strong> "ESPN", "CNN", "Food"</li>
                                <li><strong>Channel numbers:</strong> "206", "360"</li>
                                <li><strong>Current programs:</strong> "Lakers", "Breaking News"</li>
                                <li><strong>Next programs:</strong> "SportsCenter"</li>
                            </ul>
                            <h4 class="font-semibold text-blue-700 dark:text-blue-300 mb-2 mt-4">Smart Filters</h4>
                            <ul class="list-disc list-inside space-y-1 text-sm text-blue-600 dark:text-blue-400">
                                <li><strong>Sports/News:</strong> Category filtering</li>
                                <li><strong>Dynamic:</strong> Football, Basketball filters appear when games are live</li>
                                <li><strong>SD Toggle:</strong> Show/hide standard definition</li>
                            </ul>
                        </div>
                    </div>
                `,
                highlight: "#channel-search"
            },
            {
                title: "üöÄ Ready to Control Your Venue!",
                content: `
                    <div class="space-y-4">
                        <p class="text-lg"><strong>You're ready to revolutionize your TV management!</strong></p>
                        <div class="bg-gradient-to-r from-green-50 to-blue-50 dark:from-green-900/20 dark:to-blue-900/20 p-4 rounded-lg border border-green-200 dark:border-green-800">
                            <h4 class="font-semibold text-green-700 dark:text-green-300 mb-3">Key Takeaways</h4>
                            <div class="grid grid-cols-1 md:grid-cols-2 gap-4 text-sm">
                                <div>
                                    <p class="font-medium text-green-600 dark:text-green-400">Quick Operations:</p>
                                    <ul class="text-green-600 dark:text-green-400 text-xs mt-1">
                                        <li>‚Ä¢ Channel ‚Üí TV assignment</li>
                                        <li>‚Ä¢ TV ‚Üí TV copying</li>
                                        <li>‚Ä¢ Color organization</li>
                                    </ul>
                                </div>
                                <div>
                                    <p class="font-medium text-blue-600 dark:text-blue-400">Advanced Features:</p>
                                    <ul class="text-blue-600 dark:text-blue-400 text-xs mt-1">
                                        <li>‚Ä¢ Admin mode required</li>
                                        <li>‚Ä¢ Floor plans & text labels</li>
                                        <li>‚Ä¢ Channel management</li>
                                    </ul>
                                </div>
                            </div>
                        </div>
                        <div class="bg-yellow-50 dark:bg-yellow-900/20 p-4 rounded-lg border border-yellow-200 dark:border-yellow-800">
                            <p class="text-sm text-yellow-700 dark:text-yellow-300">
                                <strong>Need help?</strong> Click üìñ Help for detailed instructions or üéß Tech Support for AI-powered assistance!
                            </p>
                        </div>
                        <p class="text-center text-lg font-bold text-primary">Welcome to the future of broadcast control! üéâ</p>
                    </div>
                `,
                highlight: null
            }
        ];

        function startOnboardingTour() {
            tourActive = true;
            currentTourStep = 1;
            document.getElementById('onboarding-tour').classList.remove('hidden');
            updateTourDisplay();
        }

        function updateTourDisplay() {
            const step = tourSteps[currentTourStep - 1];
            
            // Update content
            document.getElementById('tour-step-content').innerHTML = `
                <h3 class="text-xl font-bold text-gray-900 dark:text-gray-100 mb-4">${step.title}</h3>
                ${step.content}
            `;
            
            // Update step indicator
            document.getElementById('tour-current-step').textContent = currentTourStep;
            document.getElementById('tour-total-steps').textContent = totalTourSteps;
            
            // Update navigation buttons
            const prevBtn = document.getElementById('tour-prev-btn');
            const nextBtn = document.getElementById('tour-next-btn');
            const finishBtn = document.getElementById('tour-finish-btn');
            
            prevBtn.disabled = currentTourStep === 1;
            
            if (currentTourStep === totalTourSteps) {
                nextBtn.classList.add('hidden');
                finishBtn.classList.remove('hidden');
            } else {
                nextBtn.classList.remove('hidden');
                finishBtn.classList.add('hidden');
            }
            
            // Update step dots
            document.querySelectorAll('.tour-dot').forEach((dot, index) => {
                if (index < currentTourStep) {
                    dot.className = 'tour-dot w-2 h-2 rounded-full bg-primary';
                } else {
                    dot.className = 'tour-dot w-2 h-2 rounded-full bg-gray-300 dark:bg-gray-600';
                }
            });
            
            // Show highlight
            showTourHighlight(step.highlight);
        }

        function showTourHighlight(selector) {
            const highlight = document.getElementById('tour-highlight');
            
            if (!selector) {
                highlight.classList.add('hidden');
                return;
            }
            
            const element = document.querySelector(selector);
            if (!element) {
                highlight.classList.add('hidden');
                return;
            }
            
            const rect = element.getBoundingClientRect();
            const highlightBox = highlight.querySelector('.absolute');
            
            highlightBox.style.left = (rect.left - 8) + 'px';
            highlightBox.style.top = (rect.top - 8) + 'px';
            highlightBox.style.width = (rect.width + 16) + 'px';
            highlightBox.style.height = (rect.height + 16) + 'px';
            
            highlight.classList.remove('hidden');
        }

        function nextTourStep() {
            if (currentTourStep < totalTourSteps) {
                currentTourStep++;
                updateTourDisplay();
            }
        }

        function previousTourStep() {
            if (currentTourStep > 1) {
                currentTourStep--;
                updateTourDisplay();
            }
        }

        function skipTour() {
            tourActive = false;
            document.getElementById('onboarding-tour').classList.add('hidden');
            document.getElementById('tour-highlight').classList.add('hidden');
            
            // Mark tour as completed
            if (localStorageAvailable) {
                try {
                    localStorage.setItem('nsav-tour-completed', 'true');
                } catch (error) {
                    console.log('Could not save tour completion status');
                }
            }
        }

        function checkShowTour() {
            // Check if tour was already completed
            if (localStorageAvailable) {
                try {
                    const tourCompleted = localStorage.getItem('nsav-tour-completed');
                    if (tourCompleted === 'true') {
                        return false; // Don't show tour
                    }
                } catch (error) {
                    console.log('Could not check tour completion status');
                }
            }
            
            // Show tour for first-time users
            return true;
        }

        // Enhanced app initialization with tour
        function initApp() {
            if (window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches) {
                document.documentElement.classList.add('dark');
            }
            window.matchMedia('(prefers-color-scheme: dark)').addEventListener('change', event => {
                if (event.matches) {
                    document.documentElement.classList.add('dark');
                } else {
                    document.documentElement.classList.remove('dark');
                }
            });

            processChannelData();
            createTVGrid();
            
            // Setup auto-save (checks localStorage availability)
            setupAutoSave();
            
            // Load saved state if available
            const stateLoaded = loadSystemState();
            if (stateLoaded) {
                console.log('Previous session state restored successfully');
            }
            
            // Try to auto-load floor plan if it exists in the same folder
            setTimeout(() => {
                autoLoadFloorPlan();
            }, 500);
            
            updateSportsFilters();
            renderChannels();
            document.getElementById('loading').classList.add('hidden');
            
            // Show onboarding tour for new users
            setTimeout(() => {
                if (checkShowTour()) {
                    startOnboardingTour();
                }
            }, 1000); // Small delay to let everything load
        }

        // Auto-load floor plan function
        function autoLoadFloorPlan() {
            // Try common floor plan filenames
            const floorPlanFiles = [
                'floorplan.jpg', 'floorplan.jpeg', 'floorplan.png', 'floorplan.gif',
                'floor-plan.jpg', 'floor-plan.jpeg', 'floor-plan.png', 
                'demo-floorplan.jpg', 'demo-floorplan.png'
            ];
            
            let fileIndex = 0;
            
            function tryNextFile() {
                if (fileIndex >= floorPlanFiles.length) {
                    console.log('No floor plan found in folder - user can load manually');
                    return;
                }
                
                const filename = floorPlanFiles[fileIndex];
                const img = new Image();
                
                img.onload = function() {
                    console.log(`Auto-loaded floor plan: ${filename}`);
                    loadFloorPlanFromURL(img.src, filename);
                };
                
                img.onerror = function() {
                    fileIndex++;
                    tryNextFile();
                };
                
                img.src = filename;
            }
            
            tryNextFile();
        }

        // Load floor plan from URL (for auto-loading)
        function loadFloorPlanFromURL(imageURL, filename) {
            const img = document.getElementById('floor-plan-image');
            const placeholder = document.getElementById('floor-plan-placeholder');
            const container = document.getElementById('floor-plan-container');
            
            img.src = imageURL;
            img.onload = function() {
                // Hide placeholder and show container
                placeholder.classList.add('hidden');
                container.classList.remove('hidden');
                
                // Set initial size and position
                resetImageSize();
                img.style.left = '0px';
                img.style.top = '0px';
                
                // Add dragging for floor plan
                setupFloorPlanDragging(img);
                
                floorPlanImageLoaded = true;
                
                // Show subtle notification
                updateStatusMessage(`Floor plan loaded: ${filename}`, true, 'clean');
                setTimeout(() => {
                    updateStatusMessage('', false);
                }, 4000);
            };
        }

        // Status Message Functions
        function updateStatusMessage(message, show = true, type = 'default') {
            const statusElement = document.getElementById('status-message');
            if (show && message) {
                statusElement.textContent = message;
                statusElement.classList.remove('hidden');
                
                // Clean header-style text (light blue, no background)
                if (type === 'clean') {
                    statusElement.className = 'px-4 py-1 text-xl font-bold text-cyan-500 dark:text-cyan-400 hidden';
                    statusElement.classList.remove('hidden');
                } else {
                    // Default amber badge styling
                    statusElement.className = 'px-4 py-1 text-sm font-semibold text-amber-700 dark:text-amber-300 bg-amber-100 dark:bg-amber-900/30 border border-amber-300 dark:border-amber-700 rounded-full hidden';
                    statusElement.classList.remove('hidden');
                }
            } else {
                statusElement.classList.add('hidden');
                // Reset to default styling when hiding
                statusElement.className = 'px-4 py-1 text-sm font-semibold text-amber-700 dark:text-amber-300 bg-amber-100 dark:bg-amber-900/30 border border-amber-300 dark:border-amber-700 rounded-full hidden';
            }
        }

        // Preset Management System
        let presets = {
            1: null,
            2: null,
            3: null
        };
        
        let presetTimers = {};
        let currentPresetForRecall = null;
        let activePreset = null; // Track which preset is currently active
        
        // Handle mouse down for preset buttons
        function handlePresetMouseDown(presetNum) {
            // Start 2-second timer for storing preset
            presetTimers[presetNum] = setTimeout(() => {
                // Clear the timer first so release doesn't trigger recall
                delete presetTimers[presetNum];
                storePreset(presetNum);
            }, 2000);
        }
        
        // Handle mouse up for preset buttons
        function handlePresetMouseUp(presetNum) {
            // Check if there's still a timer running (meaning it was a quick release)
            if (presetTimers[presetNum]) {
                clearTimeout(presetTimers[presetNum]);
                delete presetTimers[presetNum];
                
                // If we get here, it was a quick tap - recall preset
                recallPreset(presetNum);
            }
            // If no timer exists, it means the 2-second store already happened, so do nothing
        }
        
        // Handle touch start for preset buttons
        function handlePresetTouchStart(presetNum) {
            // Start 2-second timer for storing preset
            presetTimers[presetNum] = setTimeout(() => {
                // Clear the timer first so release doesn't trigger recall
                delete presetTimers[presetNum];
                storePreset(presetNum);
            }, 2000);
        }
        
        // Handle touch end for preset buttons
        function handlePresetTouchEnd(presetNum) {
            // Check if there's still a timer running (meaning it was a quick release)
            if (presetTimers[presetNum]) {
                clearTimeout(presetTimers[presetNum]);
                delete presetTimers[presetNum];
                
                // If we get here, it was a quick tap - recall preset
                recallPreset(presetNum);
            }
            // If no timer exists, it means the 2-second store already happened, so do nothing
        }
        
        // Store current TV assignments to preset
        function storePreset(presetNum) {
            // Create snapshot of current TV assignments
            const presetData = {
                tvAssignments: tvs.map(tv => ({
                    id: tv.id,
                    assignedChannel: tv.assignedChannel ? {
                        objectId: tv.assignedChannel.objectId,
                        name: tv.assignedChannel.name,
                        channelNum: tv.assignedChannel.channelNum,
                        displayName: tv.assignedChannel.displayName,
                        categories: tv.assignedChannel.categories,
                        program: tv.assignedChannel.program,
                        isHD: tv.assignedChannel.isHD,
                        major: tv.assignedChannel.major,
                        minor: tv.assignedChannel.minor
                    } : null,
                    assignedTuner: tv.assignedTuner
                })),
                tunerAssignments: { ...tunerAssignments },
                timestamp: new Date().toISOString()
            };
            
            // Store in preset slot
            presets[presetNum] = presetData;
            
            // Show status message
            updateStatusMessage(`Preset ${presetNum} Stored`, true, 'clean');
            setTimeout(() => {
                updateStatusMessage('', false);
            }, 3000);
            
            // Update button appearance to show it has content
            updateAllPresetButtonAppearances();
            
            console.log(`Preset ${presetNum} stored with ${presetData.tvAssignments.filter(tv => tv.assignedChannel).length} TV assignments`);
        }
        
        // Recall preset (show confirmation first)
        function recallPreset(presetNum) {
            if (!presets[presetNum]) {
                showMessage('Empty Preset', `Preset ${presetNum} is empty. Hold the button for 2 seconds to store the current TV setup.`);
                return;
            }
            
            // Set up for confirmation
            currentPresetForRecall = presetNum;
            
            // Update modal content
            document.getElementById('preset-modal-title').textContent = `Recall Preset ${presetNum}?`;
            
            // Show confirmation modal
            document.getElementById('preset-recall-modal').classList.remove('hidden');
        }
        
        // Confirm preset recall
        function confirmPresetRecall() {
            if (currentPresetForRecall === null) return;
            
            const presetData = presets[currentPresetForRecall];
            if (!presetData) return;
            
            // Store preset number before clearing currentPresetForRecall
            const presetNumber = currentPresetForRecall;
            
            // Clear current assignments (without showing confirmation message)
            clearAllTVs(false);
            
            // Restore tuner assignments first
            tunerAssignments = { ...presetData.tunerAssignments };
            updateTunerStatus();
            
            // Restore TV assignments
            presetData.tvAssignments.forEach(savedTV => {
                const tv = tvs.find(t => t.id === savedTV.id);
                if (tv && savedTV.assignedChannel) {
                    // Find the actual channel object from our channels array
                    const channel = channels.find(ch => ch.objectId === savedTV.assignedChannel.objectId);
                    if (channel) {
                        tv.assignedChannel = channel;
                        tv.assignedTuner = savedTV.assignedTuner;
                        updateTVDisplay(tv.id);
                    }
                }
            });
            
            // Set this preset as currently active
            activePreset = presetNumber;
            updateAllPresetButtonAppearances();
            
            // Refresh display
            renderChannels();
            
            // Close modal
            document.getElementById('preset-recall-modal').classList.add('hidden');
            currentPresetForRecall = null;
            
            // Show status message with correct preset number
            const assignedCount = presetData.tvAssignments.filter(tv => tv.assignedChannel).length;
            updateStatusMessage(`Preset ${presetNumber} Applied - ${assignedCount} TVs restored`, true, 'clean');
            setTimeout(() => {
                updateStatusMessage('', false);
            }, 3000);
        }
        
        // Cancel preset recall
        function cancelPresetRecall() {
            document.getElementById('preset-recall-modal').classList.add('hidden');
            currentPresetForRecall = null;
        }
        
        // Update preset button appearance
        function updatePresetButtonAppearance(presetNum, hasContent) {
            const button = document.querySelector(`button[onmousedown*="handlePresetMouseDown(${presetNum})"]`);
            if (button) {
                if (hasContent) {
                    // Button has stored content - make it more prominent
                    button.className = 'px-3 py-1 text-xs bg-green-100 text-green-700 dark:bg-green-900 dark:text-green-300 rounded hover:bg-green-200 dark:hover:bg-green-800 transition-colors font-semibold';
                } else {
                    // Button is empty - default grey appearance
                    button.className = 'px-3 py-1 text-xs bg-gray-100 text-gray-600 dark:bg-gray-700 dark:text-gray-400 rounded hover:bg-gray-200 dark:hover:bg-gray-600 transition-colors font-semibold';
                }
            }
        }
        
        // Initialize preset button appearances
        function initPresetButtons() {
            for (let i = 1; i <= 3; i++) {
                updatePresetButtonAppearance(i, presets[i] !== null);
            }
        }

        // Support Bot Integration
        function openSupportBot() {
            // The Vector Shift widget should be available after script loads
            // Typically these widgets auto-initialize or have a global function
            // If the widget has a specific API to open/show, call it here
            
            // For now, show a message that the support bot will be available
            showMessage('Tech Support', 'AI Support Bot powered by 10 years of NSAV field experience. The chat widget should appear in the bottom-right corner of your screen.');
            
            // Log for debugging
            console.log('Support bot requested - Vector Shift widget should be active');
        }

        // Clear All TVs with Confirmation
        function showConfirmClearAll() {
            // Custom confirmation modal since we can't use confirm()
            const modal = document.createElement('div');
            modal.className = 'fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50';
            modal.innerHTML = `
                <div class="bg-white dark:bg-gray-800 p-6 rounded-lg shadow-xl max-w-sm w-full mx-4">
                    <h3 class="text-lg font-semibold mb-4 text-gray-900 dark:text-gray-100">Clear All TV Assignments?</h3>
                    <p class="text-gray-600 dark:text-gray-400 mb-4">This will clear all channel assignments from all TVs and reset them to available status. This action cannot be undone.</p>
                    <div class="flex justify-end space-x-3">
                        <button onclick="this.closest('.fixed').remove()" class="px-4 py-2 text-gray-600 dark:text-gray-400 hover:bg-gray-100 dark:hover:bg-gray-700 rounded">Cancel</button>
                        <button onclick="this.closest('.fixed').remove(); clearAllTVs(true);" class="px-4 py-2 bg-red-500 text-white hover:bg-red-600 rounded">Clear All</button>
                    </div>
                </div>
            `;
            document.body.appendChild(modal);
        }

        // Drawing Tools System
        let drawingMode = false;
        let selectedDrawingTool = 'line';
        let selectedDrawingColor = 'white';
        let drawnShapes = [];
        let currentlyDrawing = false;
        let drawStartX, drawStartY;
        let previewShape = null;

        function toggleDrawingMode() {
            if (!adminMode) {
                showMessage('Admin Mode Required', 'Please enable Admin Mode to access drawing tools.');
                return;
            }
            
            // Activate drawing mode
            drawingMode = true;
            
            document.getElementById('drawing-tools-panel').classList.remove('hidden');
            updateStatusMessage('Drawing Tools Active - select tool and draw on floor plan', true, 'clean');
            
            // Select line tool by default
            selectDrawingTool('line');
        }

        function closeDrawingTools() {
            // Deactivate drawing mode
            drawingMode = false;
            
            document.getElementById('drawing-tools-panel').classList.add('hidden');
            updateStatusMessage('Drawing Mode OFF', true, 'clean');
            
            // Clear status after a moment
            setTimeout(() => {
                updateStatusMessage('', false);
            }, 2000);
        }

        function selectDrawingTool(tool) {
            selectedDrawingTool = tool;
            
            // Update button styles
            document.querySelectorAll('.drawing-tool-btn').forEach(btn => {
                btn.className = 'drawing-tool-btn p-3 border border-gray-300 dark:border-gray-600 rounded-lg hover:bg-gray-50 dark:hover:bg-gray-700 text-center';
            });
            
            const selectedBtn = document.getElementById(`tool-${tool}`);
            if (selectedBtn) {
                selectedBtn.className = 'drawing-tool-btn p-3 border-2 border-primary bg-primary/10 rounded-lg text-center';
            }
        }

        function setDrawingColor(color) {
            selectedDrawingColor = color;
            
            // Update visual feedback
            document.querySelectorAll('#drawing-tools-modal .grid button').forEach(btn => {
                btn.classList.remove('ring-2', 'ring-primary');
            });
            event.target.classList.add('ring-2', 'ring-primary');
        }

        function getDrawingColorValue(colorName) {
            const colorMap = {
                'white': '#FFFFFF',
                'red': '#EF4444',
                'blue': '#3B82F6',
                'green': '#22C55E',
                'yellow': '#FDE047',
                'purple': '#A855F7'
            };
            return colorMap[colorName] || '#FFFFFF';
        }

        function setupDrawingListeners() {
            const workspace = document.getElementById('floor-plan-workspace');
            
            // Use document-level listeners to avoid conflicts with floor plan image
            document.addEventListener('mousedown', handleDrawingMouseDown);
            document.addEventListener('mousemove', handleDrawingMouseMove);
            document.addEventListener('mouseup', handleDrawingMouseUp);
            
            // Touch support
            document.addEventListener('touchstart', handleDrawingTouchStart, { passive: false });
            document.addEventListener('touchmove', handleDrawingTouchMove, { passive: false });
            document.addEventListener('touchend', handleDrawingTouchEnd);
        }

        function handleDrawingMouseDown(e) {
            // Only handle drawing if we're in drawing mode, on the workspace, and click is on background
            if (!drawingMode || !adminMode) return;
            
            const workspace = document.getElementById('floor-plan-workspace');
            if (!workspace.contains(e.target)) return;
            
            // Check if we clicked on the workspace background (not a TV or other element)
            if (e.target !== workspace && !workspace.contains(e.target)) return;
            
            currentlyDrawing = true;
            const rect = workspace.getBoundingClientRect();
            drawStartX = e.clientX - rect.left;
            drawStartY = e.clientY - rect.top;
            
            e.preventDefault();
            e.stopPropagation();
        }

        function handleDrawingMouseMove(e) {
            if (!currentlyDrawing || !drawingMode || !adminMode) return;
            
            const workspace = document.getElementById('floor-plan-workspace');
            const rect = workspace.getBoundingClientRect();
            const currentX = e.clientX - rect.left;
            const currentY = e.clientY - rect.top;
            
            // Remove previous preview
            if (previewShape) {
                previewShape.remove();
                previewShape = null;
            }
            
            // Create preview shape
            previewShape = createShape(drawStartX, drawStartY, currentX, currentY, true);
            if (previewShape) {
                workspace.appendChild(previewShape);
            }
            
            e.preventDefault();
        }

        function handleDrawingMouseUp(e) {
            if (!currentlyDrawing || !drawingMode || !adminMode) return;
            
            const workspace = document.getElementById('floor-plan-workspace');
            const rect = workspace.getBoundingClientRect();
            const endX = e.clientX - rect.left;
            const endY = e.clientY - rect.top;
            
            // Remove preview
            if (previewShape) {
                previewShape.remove();
                previewShape = null;
            }
            
            // Create final shape
            const shape = createShape(drawStartX, drawStartY, endX, endY, false);
            if (shape) {
                workspace.appendChild(shape);
                drawnShapes.push({
                    id: shape.id,
                    tool: selectedDrawingTool,
                    startX: drawStartX,
                    startY: drawStartY,
                    endX: endX,
                    endY: endY,
                    color: selectedDrawingColor,
                    lineWidth: document.getElementById('line-width').value,
                    fillStyle: document.getElementById('fill-style').value
                });
            }
            
            currentlyDrawing = false;
            e.preventDefault();
        }

        function handleDrawingTouchStart(e) {
            if (!drawingMode || !adminMode) return;
            
            const workspace = document.getElementById('floor-plan-workspace');
            if (!workspace.contains(e.target)) return;
            
            currentlyDrawing = true;
            const rect = workspace.getBoundingClientRect();
            const touch = e.touches[0];
            drawStartX = touch.clientX - rect.left;
            drawStartY = touch.clientY - rect.top;
            
            e.preventDefault();
        }

        function handleDrawingTouchMove(e) {
            if (!currentlyDrawing || !drawingMode || !adminMode) return;
            
            const workspace = document.getElementById('floor-plan-workspace');
            const rect = workspace.getBoundingClientRect();
            const touch = e.touches[0];
            const currentX = touch.clientX - rect.left;
            const currentY = touch.clientY - rect.top;
            
            // Remove previous preview
            if (previewShape) {
                previewShape.remove();
                previewShape = null;
            }
            
            // Create preview shape
            previewShape = createShape(drawStartX, drawStartY, currentX, currentY, true);
            if (previewShape) {
                workspace.appendChild(previewShape);
            }
            
            e.preventDefault();
        }

        function handleDrawingTouchEnd(e) {
            if (!currentlyDrawing || !drawingMode || !adminMode) return;
            
            const workspace = document.getElementById('floor-plan-workspace');
            const rect = workspace.getBoundingClientRect();
            const touch = e.changedTouches[0];
            const endX = touch.clientX - rect.left;
            const endY = touch.clientY - rect.top;
            
            // Remove preview
            if (previewShape) {
                previewShape.remove();
                previewShape = null;
            }
            
            // Create final shape
            const shape = createShape(drawStartX, drawStartY, endX, endY, false);
            if (shape) {
                workspace.appendChild(shape);
                drawnShapes.push({
                    id: shape.id,
                    tool: selectedDrawingTool,
                    startX: drawStartX,
                    startY: drawStartY,
                    endX: endX,
                    endY: endY,
                    color: selectedDrawingColor,
                    lineWidth: document.getElementById('line-width').value,
                    fillStyle: document.getElementById('fill-style').value
                });
            }
            
            currentlyDrawing = false;
            e.preventDefault();
        }

        function createShape(startX, startY, endX, endY, isPreview) {
            const lineWidth = document.getElementById('line-width').value;
            const fillStyle = document.getElementById('fill-style').value;
            const color = getDrawingColorValue(selectedDrawingColor);
            
            if (selectedDrawingTool === 'line') {
                return createLine(startX, startY, endX, endY, color, lineWidth, isPreview);
            } else if (selectedDrawingTool === 'rectangle') {
                return createRectangle(startX, startY, endX, endY, color, lineWidth, fillStyle, isPreview);
            } else if (selectedDrawingTool === 'circle') {
                return createCircle(startX, startY, endX, endY, color, lineWidth, fillStyle, isPreview);
            }
            
            return null;
        }

        function createLine(startX, startY, endX, endY, color, lineWidth, isPreview) {
            const line = document.createElement('div');
            line.id = isPreview ? 'preview-shape' : `shape-${Date.now()}`;
            
            const length = Math.sqrt(Math.pow(endX - startX, 2) + Math.pow(endY - startY, 2));
            const angle = Math.atan2(endY - startY, endX - startX) * 180 / Math.PI;
            
            line.className = 'absolute pointer-events-auto cursor-move';
            line.style.left = startX + 'px';
            line.style.top = startY + 'px';
            line.style.width = length + 'px';
            line.style.height = lineWidth + 'px';
            line.style.backgroundColor = color;
            line.style.transformOrigin = '0 50%';
            line.style.transform = `rotate(${angle}deg)`;
            line.style.zIndex = '8'; // Below text but above floor plan
            line.style.opacity = isPreview ? '0.7' : '1';
            line.style.transition = 'opacity 0.2s ease';
            
            if (!isPreview) {
                // Add dragging functionality
                setupShapeDragging(line);
                
                // Add double-click to delete
                line.ondblclick = (e) => {
                    if (adminMode) {
                        deleteShape(line.id);
                        e.stopPropagation();
                    }
                };
                
                // Add hover effect
                line.onmouseenter = () => line.style.opacity = '0.8';
                line.onmouseleave = () => line.style.opacity = '1';
            }
            
            return line;
        }

        function createRectangle(startX, startY, endX, endY, color, lineWidth, fillStyle, isPreview) {
            const rect = document.createElement('div');
            rect.id = isPreview ? 'preview-shape' : `shape-${Date.now()}`;
            
            const left = Math.min(startX, endX);
            const top = Math.min(startY, endY);
            const width = Math.abs(endX - startX);
            const height = Math.abs(endY - startY);
            
            rect.className = 'absolute pointer-events-auto cursor-move';
            rect.style.left = left + 'px';
            rect.style.top = top + 'px';
            rect.style.width = width + 'px';
            rect.style.height = height + 'px';
            rect.style.border = `${lineWidth}px solid ${color}`;
            rect.style.zIndex = '8'; // Below text but above floor plan
            rect.style.opacity = isPreview ? '0.7' : '1';
            rect.style.transition = 'opacity 0.2s ease';
            
            if (fillStyle === 'solid') {
                rect.style.backgroundColor = color;
            } else if (fillStyle === 'transparent') {
                rect.style.backgroundColor = color + '40'; // 25% opacity
            }
            
            if (!isPreview) {
                // Add dragging functionality
                setupShapeDragging(rect);
                
                // Add double-click to delete
                rect.ondblclick = (e) => {
                    if (adminMode) {
                        deleteShape(rect.id);
                        e.stopPropagation();
                    }
                };
                
                // Add hover effect
                rect.onmouseenter = () => rect.style.opacity = '0.8';
                rect.onmouseleave = () => rect.style.opacity = '1';
            }
            
            return rect;
        }

        function createCircle(startX, startY, endX, endY, color, lineWidth, fillStyle, isPreview) {
            const circle = document.createElement('div');
            circle.id = isPreview ? 'preview-shape' : `shape-${Date.now()}`;
            
            const centerX = (startX + endX) / 2;
            const centerY = (startY + endY) / 2;
            const radius = Math.sqrt(Math.pow(endX - startX, 2) + Math.pow(endY - startY, 2)) / 2;
            
            circle.className = 'absolute pointer-events-auto cursor-move';
            circle.style.left = (centerX - radius) + 'px';
            circle.style.top = (centerY - radius) + 'px';
            circle.style.width = (radius * 2) + 'px';
            circle.style.height = (radius * 2) + 'px';
            circle.style.border = `${lineWidth}px solid ${color}`;
            circle.style.borderRadius = '50%';
            circle.style.zIndex = '8'; // Below text but above floor plan
            circle.style.opacity = isPreview ? '0.7' : '1';
            circle.style.transition = 'opacity 0.2s ease';
            
            if (fillStyle === 'solid') {
                circle.style.backgroundColor = color;
            } else if (fillStyle === 'transparent') {
                circle.style.backgroundColor = color + '40'; // 25% opacity
            }
            
            if (!isPreview) {
                // Add dragging functionality
                setupShapeDragging(circle);
                
                // Add double-click to delete
                circle.ondblclick = (e) => {
                    if (adminMode) {
                        deleteShape(circle.id);
                        e.stopPropagation();
                    }
                };
                
                // Add hover effect
                circle.onmouseenter = () => circle.style.opacity = '0.8';
                circle.onmouseleave = () => circle.style.opacity = '1';
            }
            
            return circle;
        }

        function deleteShape(shapeId) {
            const shape = document.getElementById(shapeId);
            if (shape) {
                shape.remove();
                drawnShapes = drawnShapes.filter(s => s.id !== shapeId);
            }
        }

        function clearAllDrawings() {
            drawnShapes.forEach(shape => {
                const element = document.getElementById(shape.id);
                if (element) element.remove();
            });
            drawnShapes = [];
            showMessage('Drawings Cleared', 'All drawn shapes have been removed from the floor plan.');
        }

        // Unified Annotation Tools Functions
        function setSharedColor(color) {
            selectedDrawingColor = color;
            selectedTextColor = color;
            
            // Update visual feedback for all color buttons
            document.querySelectorAll('#drawing-tools-panel .grid button').forEach(btn => {
                btn.classList.remove('ring-2', 'ring-primary');
            });
            
            const colorButton = document.getElementById(`color-${color}`);
            if (colorButton) {
                colorButton.classList.add('ring-2', 'ring-primary');
            }
        }

        function handleQuickTextKeyPress(event) {
            if (event.key === 'Enter') {
                insertQuickTextLabel();
            }
        }

        function insertQuickTextLabel() {
            const textInput = document.getElementById('text-input');
            const sizeSelect = document.getElementById('text-size');
            const text = textInput.value.trim();
            
            if (!text) {
                showMessage('Empty Text', 'Please enter some text for the label.');
                return;
            }
            
            const workspace = document.getElementById('floor-plan-workspace');
            const textElement = document.createElement('div');
            
            // Generate unique ID
            const textId = `text-label-${Date.now()}`;
            textElement.id = textId;
            
            // Set up the text element with dragging capability
            textElement.className = `absolute cursor-move pointer-events-auto font-bold select-none ${sizeSelect.value}`;
            textElement.style.color = getTextColorValue(selectedTextColor);
            textElement.style.textShadow = '1px 1px 2px rgba(0,0,0,0.8)'; // Better visibility
            textElement.style.zIndex = '15'; // Above TVs
            textElement.textContent = text;
            
            // Position in the center of the workspace
            const centerX = (workspace.clientWidth - 200) / 2; // Estimate text width
            const centerY = workspace.clientHeight / 2;
            textElement.style.left = centerX + 'px';
            textElement.style.top = centerY + 'px';
            
            // Add dragging functionality
            setupTextLabelDragging(textElement);
            
            // Add double-click to edit/delete
            textElement.ondblclick = (e) => {
                if (adminMode) {
                    editQuickTextLabel(textId);
                    e.stopPropagation();
                }
            };
            
            // Store in array
            textLabels.push({
                id: textId,
                text: text,
                color: selectedTextColor,
                size: sizeSelect.value,
                x: centerX,
                y: centerY
            });
            
            // Add to workspace
            workspace.appendChild(textElement);
            
            // Clear the input for next use
            textInput.value = '';
        }

        function editQuickTextLabel(textId) {
            const labelData = textLabels.find(label => label.id === textId);
            if (!labelData) return;
            
            // Populate the form with existing data
            document.getElementById('text-input').value = labelData.text;
            document.getElementById('text-size').value = labelData.size;
            selectedTextColor = labelData.color;
            
            // Update color selection visual feedback
            setSharedColor(labelData.color);
            
            // Remove the old label
            const element = document.getElementById(textId);
            if (element) element.remove();
            textLabels = textLabels.filter(label => label.id !== textId);
        }

        function setupShapeDragging(element) {
            let isDraggingShape = false;
            let shapeDragStartX, shapeDragStartY, shapeStartLeft, shapeStartTop;
            
            element.addEventListener('mousedown', (e) => {
                if (e.button === 0 && adminMode) {
                    isDraggingShape = true;
                    shapeDragStartX = e.clientX;
                    shapeDragStartY = e.clientY;
                    shapeStartLeft = parseInt(element.style.left) || 0;
                    shapeStartTop = parseInt(element.style.top) || 0;
                    element.style.zIndex = '1000';
                    element.style.opacity = '0.8';
                    
                    // CRITICAL: Stop all event propagation to prevent drawing mode from interfering
                    e.preventDefault();
                    e.stopPropagation();
                    e.stopImmediatePropagation();
                }
            });
            
            // Touch events for tablets
            element.addEventListener('touchstart', (e) => {
                if (adminMode) {
                    const touch = e.touches[0];
                    isDraggingShape = true;
                    shapeDragStartX = touch.clientX;
                    shapeDragStartY = touch.clientY;
                    shapeStartLeft = parseInt(element.style.left) || 0;
                    shapeStartTop = parseInt(element.style.top) || 0;
                    element.style.zIndex = '1000';
                    element.style.opacity = '0.8';
                    e.preventDefault();
                    e.stopPropagation();
                    e.stopImmediatePropagation();
                }
            });
            
            const handleShapeMouseMove = (e) => {
                if (isDraggingShape) {
                    const deltaX = e.clientX - shapeDragStartX;
                    const deltaY = e.clientY - shapeDragStartY;
                    
                    const workspace = document.getElementById('floor-plan-workspace');
                    const newLeft = Math.max(0, Math.min(shapeStartLeft + deltaX, workspace.clientWidth - 50));
                    const newTop = Math.max(0, Math.min(shapeStartTop + deltaY, workspace.clientHeight - 50));
                    
                    element.style.left = newLeft + 'px';
                    element.style.top = newTop + 'px';
                    e.preventDefault();
                }
            };
            
            const handleShapeTouchMove = (e) => {
                if (isDraggingShape) {
                    const touch = e.touches[0];
                    const deltaX = touch.clientX - shapeDragStartX;
                    const deltaY = touch.clientY - shapeDragStartY;
                    
                    const workspace = document.getElementById('floor-plan-workspace');
                    const newLeft = Math.max(0, Math.min(shapeStartLeft + deltaX, workspace.clientWidth - 50));
                    const newTop = Math.max(0, Math.min(shapeStartTop + deltaY, workspace.clientHeight - 50));
                    
                    element.style.left = newLeft + 'px';
                    element.style.top = newTop + 'px';
                    e.preventDefault();
                }
            };
            
            const handleShapeMouseUp = (e) => {
                if (isDraggingShape) {
                    isDraggingShape = false;
                    element.style.zIndex = '8';
                    element.style.opacity = '1';
                    e.preventDefault();
                }
            };
            
            const handleShapeTouchEnd = (e) => {
                if (isDraggingShape) {
                    isDraggingShape = false;
                    element.style.zIndex = '8';
                    element.style.opacity = '1';
                    e.preventDefault();
                }
            };
            
            document.addEventListener('mousemove', handleShapeMouseMove);
            document.addEventListener('mouseup', handleShapeMouseUp);
            document.addEventListener('touchmove', handleShapeTouchMove, { passive: false });
            document.addEventListener('touchend', handleShapeTouchEnd);
        }

        function clearAllAnnotations() {
            // Clear all drawings
            drawnShapes.forEach(shape => {
                const element = document.getElementById(shape.id);
                if (element) element.remove();
            });
            drawnShapes = [];
            
            // Clear all text labels
            textLabels.forEach(label => {
                const element = document.getElementById(label.id);
                if (element) element.remove();
            });
            textLabels = [];
            
            showMessage('Annotations Cleared', 'All drawings and text labels have been removed from the floor plan.');
        }

        // Workspace click handler
        function handleWorkspaceClick(event) {
            // If drawing mode is active and this is the workspace background, drawing handlers will handle it
            if (drawingMode && adminMode && event.target === event.currentTarget) {
                return;
            }
            
            // If this click was on a shape or TV, don't clear channel selection
            if (event.target !== event.currentTarget) {
                return;
            }
            
            // Normal behavior - clear channel selection
            clearChannelSelection();
        }

        // Auto-load demo state if available
        async function loadDemoFromFile() {
            try {
                const response = await fetch('demo-state.json');
                if (response.ok) {
                    const demoState = await response.json();
                    restoreDemoState(demoState);
                    console.log('Demo state loaded successfully!');
                }
            } catch (error) {
                console.log('Demo state file not found - starting fresh');
            }
        }

        function restoreDemoState(state) {
            // Clear current state first
            clearAllTVs(false);
            
            // Restore TV positions and assignments
            if (state.tvAssignments && state.tvAssignments.length > 0) {
                state.tvAssignments.forEach(savedTV => {
                    const tv = tvs.find(t => t.id === savedTV.id);
                    if (tv) {
                        tv.x = savedTV.x || tv.x;
                        tv.y = savedTV.y || tv.y;
                        tv.assignedChannel = savedTV.assignedChannel;
                        tv.assignedTuner = savedTV.assignedTuner;
                        
                        // Update position
                        const tvElement = document.getElementById(`tv-${tv.id}`);
                        if (tvElement) {
                            tvElement.style.left = tv.x + 'px';
                            tvElement.style.top = tv.y + 'px';
                        }
                        
                        // Update display
                        updateTVDisplay(tv.id);
                    }
                });
            }
            
            // Restore other state
            if (state.tunerAssignments) {
                tunerAssignments = state.tunerAssignments;
                updateTunerStatus();
            }
            
            if (state.hiddenChannels) {
                hiddenChannels = new Set(state.hiddenChannels);
            }
            
            if (state.channelColors) {
                channelColors = state.channelColors;
            }
            
            if (state.programPrefixes) {
                programPrefixes = state.programPrefixes;
            }
            
            if (state.textLabels) {
                textLabels = state.textLabels;
                // Recreate text labels on the floor plan
                state.textLabels.forEach(label => {
                    const workspace = document.getElementById('floor-plan-workspace');
                    const textElement = document.createElement('div');
                    textElement.id = label.id;
                    textElement.className = `absolute cursor-move pointer-events-auto font-bold select-none ${label.size}`;
                    textElement.style.color = getTextColorValue(label.color);
                    textElement.style.textShadow = '1px 1px 2px rgba(0,0,0,0.8)';
                    textElement.style.zIndex = '15';
                    textElement.style.left = label.x + 'px';
                    textElement.style.top = label.y + 'px';
                    textElement.textContent = label.text;
                    
                    setupTextLabelDragging(textElement);
                    textElement.ondblclick = (e) => {
                        if (adminMode) {
                            editQuickTextLabel(label.id);
                            e.stopPropagation();
                        }
                    };
                    
                    workspace.appendChild(textElement);
                });
            }
            
            if (state.drawnShapes) {
                drawnShapes = state.drawnShapes;
                // Recreate drawn shapes would go here if needed
            }
            
            if (state.presets) {
                presets = state.presets;
                updateAllPresetButtonAppearances();
            }
            
            if (state.activePreset !== undefined) {
                activePreset = state.activePreset;
            }
            
            // Refresh displays
            renderChannels();
            updateAllTVDisplays();
            applyChannelColors();
            
            console.log('Demo state fully restored');
        }

        document.addEventListener('DOMContentLoaded', () => {
            initApp();
            setupDrawingListeners();
            // Load demo state after everything is initialized
            setTimeout(loadDemoFromFile, 1000);
        });
    </script>


</body></html>
